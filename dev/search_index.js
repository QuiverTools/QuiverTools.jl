var documenterSearchIndex = {"docs":
[{"location":"benchmarks/#Benchmarks","page":"Benchmarks","title":"Benchmarks","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"These are the benchmarks for the functions in QuiverTools.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"The benchmarks were generated by running","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"julia --project benchmark/benchmarks.jl","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"from the root of the repository. This was done on a 2021 MacBook Pro with a M1 Pro chip and 16 GB of RAM.","category":"page"},{"location":"benchmarks/#Benchmarking-is_acyclic","page":"Benchmarks","title":"Benchmarking is_acyclic","text":"","category":"section"},{"location":"benchmarks/#Datum:-Quiver[5-Kronecker-quiver,-with-adjacency-matrix-[0-5;-0-0]]","page":"Benchmarks","title":"Datum: Quiver[5-Kronecker quiver, with adjacency matrix [0 5; 0 0]]","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"BenchmarkTools.Trial: 10000 samples with 4 evaluations.\n Range (min … max):  7.312 μs …  31.698 μs  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     7.615 μs               ┊ GC (median):    0.00%\n Time  (mean ± σ):   7.691 μs ± 828.352 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n     ▃   ▁ ▁ █▄█                                               \n  ▂▆▆█▆▇▅█▆███████▄▄▂▃▃▂▃▂▂▂▂▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁ ▂\n  7.31 μs         Histogram: frequency by time        8.86 μs <\n\n Memory estimate: 1.72 KiB, allocs estimate: 29.","category":"page"},{"location":"benchmarks/#Benchmarking-is_connected","page":"Benchmarks","title":"Benchmarking is_connected","text":"","category":"section"},{"location":"benchmarks/#Datum:-Quiver[5-Kronecker-quiver,-with-adjacency-matrix-[0-5;-0-0]]-2","page":"Benchmarks","title":"Datum: Quiver[5-Kronecker quiver, with adjacency matrix [0 5; 0 0]]","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"BenchmarkTools.Trial: 10000 samples with 3 evaluations.\n Range (min … max):  8.708 μs …  17.208 μs  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     8.889 μs               ┊ GC (median):    0.00%\n Time  (mean ± σ):   9.006 μs ± 407.506 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n     ▆█▇▅▁                                                     \n  ▁▃██████▆▅▃▃▃▂▂▃▃▃▃▃▂▂▂▂▂▂▁▂▁▂▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁ ▂\n  8.71 μs         Histogram: frequency by time        10.4 μs <\n\n Memory estimate: 2.41 KiB, allocs estimate: 45.","category":"page"},{"location":"benchmarks/#Benchmarking-all_HN_types","page":"Benchmarks","title":"Benchmarking all_HN_types","text":"","category":"section"},{"location":"benchmarks/#Datum:-(3-Kronecker-quiver,-with-adjacency-matrix-[0-3;-0-0],-[2,-3],-[3,-2])","page":"Benchmarks","title":"Datum: (3-Kronecker quiver, with adjacency matrix [0 3; 0 0], [2, 3], [3, -2])","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"BenchmarkTools.Trial: 10000 samples with 1 evaluation.\n Range (min … max):  131.792 μs …   6.021 ms  ┊ GC (min … max): 0.00% … 95.25%\n Time  (median):     137.458 μs               ┊ GC (median):    0.00%\n Time  (mean ± σ):   149.601 μs ± 241.364 μs  ┊ GC (mean ± σ):  6.86% ±  4.15%\n\n   ▂█▆▃  ▁▄▂                                                     \n  ▃█████▇████▇▆▅▅▅▅▄▅▄▄▃▃▃▃▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▁▂▁▂▂▂▂▂▂▂▂▂▂ ▃\n  132 μs           Histogram: frequency by time          176 μs <\n\n Memory estimate: 162.94 KiB, allocs estimate: 2349.","category":"page"},{"location":"benchmarks/#Datum:-(5-Kronecker-quiver,-with-adjacency-matrix-[0-5;-0-0],-[2,-3],-[3,-2])","page":"Benchmarks","title":"Datum: (5-Kronecker quiver, with adjacency matrix [0 5; 0 0], [2, 3], [3, -2])","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"BenchmarkTools.Trial: 10000 samples with 1 evaluation.\n Range (min … max):  132.125 μs …   5.925 ms  ┊ GC (min … max): 0.00% … 95.40%\n Time  (median):     139.458 μs               ┊ GC (median):    0.00%\n Time  (mean ± σ):   153.442 μs ± 238.650 μs  ┊ GC (mean ± σ):  6.40% ±  4.05%\n\n     █▄                                                          \n  ▄▆▆███▆▅▄▄▃▃▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▁▂▂▂▂▂▂▂▂▂▂▂▂▁▂▂▂▂▂▂▂▁▂▂▂▂▂▂▁▂▂▂▂ ▃\n  132 μs           Histogram: frequency by time          235 μs <\n\n Memory estimate: 162.84 KiB, allocs estimate: 2347.","category":"page"},{"location":"benchmarks/#Benchmarking-all_Teleman_bounds","page":"Benchmarks","title":"Benchmarking all_Teleman_bounds","text":"","category":"section"},{"location":"benchmarks/#Datum:-(3-Kronecker-quiver,-with-adjacency-matrix-[0-3;-0-0],-[2,-3],-[3,-2])-2","page":"Benchmarks","title":"Datum: (3-Kronecker quiver, with adjacency matrix [0 3; 0 0], [2, 3], [3, -2])","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"BenchmarkTools.Trial: 10000 samples with 1 evaluation.\n Range (min … max):  162.875 μs …   5.935 ms  ┊ GC (min … max): 0.00% … 94.14%\n Time  (median):     166.417 μs               ┊ GC (median):    0.00%\n Time  (mean ± σ):   179.764 μs ± 250.318 μs  ┊ GC (mean ± σ):  6.20% ±  4.31%\n\n    ▇█▅▂▂                                                        \n  ▃▆██████▇▆▅▄▄▃▃▃▃▃▃▃▃▃▃▂▃▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▁▂▂▂▂▂▂▂▂▂▂▂▂▂ ▃\n  163 μs           Histogram: frequency by time          202 μs <\n\n Memory estimate: 185.22 KiB, allocs estimate: 2763.","category":"page"},{"location":"benchmarks/#Datum:-(5-Kronecker-quiver,-with-adjacency-matrix-[0-5;-0-0],-[2,-3],-[3,-2])-2","page":"Benchmarks","title":"Datum: (5-Kronecker quiver, with adjacency matrix [0 5; 0 0], [2, 3], [3, -2])","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"BenchmarkTools.Trial: 10000 samples with 1 evaluation.\n Range (min … max):  163.375 μs …  18.910 ms  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     167.542 μs               ┊ GC (median):    0.00%\n Time  (mean ± σ):   186.526 μs ± 346.495 μs  ┊ GC (mean ± σ):  6.37% ± 4.43%\n\n   ▂█▄▁▁                                                         \n  ▃██████▆▅▃▃▃▃▃▂▂▂▂▂▂▂▂▂▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁ ▂\n  163 μs           Histogram: frequency by time          214 μs <\n\n Memory estimate: 185.12 KiB, allocs estimate: 2761.","category":"page"},{"location":"benchmarks/#Benchmarking-Euler_form","page":"Benchmarks","title":"Benchmarking Euler_form","text":"","category":"section"},{"location":"benchmarks/#Datum:-(3-Kronecker-quiver,-with-adjacency-matrix-[0-3;-0-0],-[2,-3],-[3,-2])-3","page":"Benchmarks","title":"Datum: (3-Kronecker quiver, with adjacency matrix [0 3; 0 0], [2, 3], [3, -2])","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"BenchmarkTools.Trial: 10000 samples with 1 evaluation.\n Range (min … max):  8.958 μs …  37.500 μs  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     9.250 μs               ┊ GC (median):    0.00%\n Time  (mean ± σ):   9.394 μs ± 832.278 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n  ▂▅▆█▇▆▇▅▅▅▃▃▂▃▁▁▂▁▁▁  ▂▁  ▁                                 ▂\n  ████████████████████████▇██▇██▇▇█▇▆▆▇▅▅▅▄▅▆▄▃▄▃▃▃▃▄▃▃▁▄▃▁▁▅ █\n  8.96 μs      Histogram: log(frequency) by time      12.2 μs <\n\n Memory estimate: 4.09 KiB, allocs estimate: 66.","category":"page"},{"location":"benchmarks/#Datum:-(5-Kronecker-quiver,-with-adjacency-matrix-[0-5;-0-0],-[2,-3],-[3,-2])-3","page":"Benchmarks","title":"Datum: (5-Kronecker quiver, with adjacency matrix [0 5; 0 0], [2, 3], [3, -2])","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"BenchmarkTools.Trial: 10000 samples with 1 evaluation.\n Range (min … max):  9.000 μs …  32.959 μs  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     9.250 μs               ┊ GC (median):    0.00%\n Time  (mean ± σ):   9.367 μs ± 723.138 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n  ▂▅████▇▇▇▆▆▅▄▄▄▃▃▃▂▁▁▁  ▁ ▁▁▁ ▁▁   ▁                        ▃\n  █████████████████████████████▁█████████▇▇▇█▆▇▇▆▆▇▇▅▅▆▃▄▃▃▁▄ █\n  9 μs         Histogram: log(frequency) by time      11.4 μs <\n\n Memory estimate: 4.09 KiB, allocs estimate: 66.","category":"page"},{"location":"benchmarks/#Benchmarking-has_semistables","page":"Benchmarks","title":"Benchmarking has_semistables","text":"","category":"section"},{"location":"benchmarks/#Datum:-(3-Kronecker-quiver,-with-adjacency-matrix-[0-3;-0-0],-[2,-3],-[3,-2])-4","page":"Benchmarks","title":"Datum: (3-Kronecker quiver, with adjacency matrix [0 3; 0 0], [2, 3], [3, -2])","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"BenchmarkTools.Trial: 10000 samples with 1 evaluation.\n Range (min … max):  50.541 μs …   5.355 ms  ┊ GC (min … max): 0.00% … 97.43%\n Time  (median):     52.458 μs               ┊ GC (median):    0.00%\n Time  (mean ± σ):   56.467 μs ± 134.521 μs  ┊ GC (mean ± σ):  6.22% ±  2.58%\n\n       ▁▂▃▄▅█▅█▆▂                                               \n  ▁▁▂▄▆███████████▆▅▄▄▃▃▃▃▃▃▃▂▃▂▂▂▂▁▂▁▂▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁ ▃\n  50.5 μs         Histogram: frequency by time         60.3 μs <\n\n Memory estimate: 68.67 KiB, allocs estimate: 937.","category":"page"},{"location":"benchmarks/#Datum:-(5-Kronecker-quiver,-with-adjacency-matrix-[0-5;-0-0],-[2,-3],-[3,-2])-4","page":"Benchmarks","title":"Datum: (5-Kronecker quiver, with adjacency matrix [0 5; 0 0], [2, 3], [3, -2])","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"BenchmarkTools.Trial: 10000 samples with 1 evaluation.\n Range (min … max):  51.041 μs …   5.126 ms  ┊ GC (min … max): 0.00% … 97.70%\n Time  (median):     52.792 μs               ┊ GC (median):    0.00%\n Time  (mean ± σ):   57.190 μs ± 142.731 μs  ┊ GC (mean ± σ):  6.96% ±  2.76%\n\n           ▅▄█▃▅                                                \n  ▂▂▃▃▅▅▆▆███████▇▇▄▄▄▄▃▃▃▃▃▃▃▃▃▃▃▃▂▃▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▁▂▂▂▂▂▂▂ ▃\n  51 μs           Histogram: frequency by time         59.6 μs <\n\n Memory estimate: 68.77 KiB, allocs estimate: 939.","category":"page"},{"location":"benchmarks/#Benchmarking-_Hodge_polynomial_fast","page":"Benchmarks","title":"Benchmarking _Hodge_polynomial_fast","text":"","category":"section"},{"location":"benchmarks/#Datum:-(5-Kronecker-quiver,-with-adjacency-matrix-[0-5;-0-0],-[2,-3],-[3,-2])-5","page":"Benchmarks","title":"Datum: (5-Kronecker quiver, with adjacency matrix [0 5; 0 0], [2, 3], [3, -2])","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"BenchmarkTools.Trial: 491 samples with 1 evaluation.\n Range (min … max):   6.137 ms … 99.873 ms  ┊ GC (min … max):  0.00% … 41.34%\n Time  (median):      6.388 ms              ┊ GC (median):     0.00%\n Time  (mean ± σ):   10.170 ms ± 17.316 ms  ┊ GC (mean ± σ):  16.13% ±  8.44%\n\n  █                                                            \n  █▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▄▁▁▁▄▁▁▁▁▁▁▁▁▁▄▁▄▁▄▁█ ▆\n  6.14 ms      Histogram: log(frequency) by time        93 ms <\n\n Memory estimate: 5.11 MiB, allocs estimate: 195437.","category":"page"},{"location":"benchmarks/#Benchmarking-is_Schur_root","page":"Benchmarks","title":"Benchmarking is_Schur_root","text":"","category":"section"},{"location":"benchmarks/#Datum:-(5-Kronecker-quiver,-with-adjacency-matrix-[0-5;-0-0],-[2,-3])","page":"Benchmarks","title":"Datum: (5-Kronecker quiver, with adjacency matrix [0 5; 0 0], [2, 3])","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"BenchmarkTools.Trial: 10000 samples with 1 evaluation.\n Range (min … max):  52.625 μs …   5.122 ms  ┊ GC (min … max): 0.00% … 97.55%\n Time  (median):     54.250 μs               ┊ GC (median):    0.00%\n Time  (mean ± σ):   58.973 μs ± 142.264 μs  ┊ GC (mean ± σ):  6.72% ±  2.76%\n\n     ▂▃█▅▄                                                      \n  ▂▃▄██████▇▅▅▄▄▄▄▄▄▃▃▃▃▃▃▃▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▁▂▂▂▂▂▂▁▂▂▂▂▂ ▃\n  52.6 μs         Histogram: frequency by time         66.4 μs <\n\n Memory estimate: 71.55 KiB, allocs estimate: 973.","category":"page"},{"location":"benchmarks/#Datum:-(3-Kronecker-quiver,-with-adjacency-matrix-[0-3;-0-0],-[2,-3])","page":"Benchmarks","title":"Datum: (3-Kronecker quiver, with adjacency matrix [0 3; 0 0], [2, 3])","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"BenchmarkTools.Trial: 10000 samples with 1 evaluation.\n Range (min … max):  52.542 μs …   5.142 ms  ┊ GC (min … max): 0.00% … 97.51%\n Time  (median):     53.958 μs               ┊ GC (median):    0.00%\n Time  (mean ± σ):   58.738 μs ± 142.469 μs  ┊ GC (mean ± σ):  6.76% ±  2.75%\n\n     ▅▆█▃▁                                                      \n  ▂▄██████▇▆▄▄▄▃▄▃▃▄▄▃▃▃▃▃▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▁▂ ▃\n  52.5 μs         Histogram: frequency by time         65.9 μs <\n\n Memory estimate: 71.45 KiB, allocs estimate: 971.","category":"page"},{"location":"benchmarks/#Benchmarking-canonical_decomposition","page":"Benchmarks","title":"Benchmarking canonical_decomposition","text":"","category":"section"},{"location":"benchmarks/#Datum:-(5-Kronecker-quiver,-with-adjacency-matrix-[0-5;-0-0],-[2,-3])-2","page":"Benchmarks","title":"Datum: (5-Kronecker quiver, with adjacency matrix [0 5; 0 0], [2, 3])","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"BenchmarkTools.Trial: 10000 samples with 1 evaluation.\n Range (min … max):  67.792 μs …   5.214 ms  ┊ GC (min … max): 0.00% … 96.74%\n Time  (median):     69.625 μs               ┊ GC (median):    0.00%\n Time  (mean ± σ):   76.013 μs ± 169.340 μs  ┊ GC (mean ± σ):  7.28% ±  3.22%\n\n     ▄▅█▆▂▁                                                     \n  ▂▃▅██████▆▅▄▄▄▄▄▃▄▃▃▃▂▃▃▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▁▂▂▂▂▂▂▂▂▁▂▂▂▂▂ ▃\n  67.8 μs         Histogram: frequency by time         84.2 μs <\n\n Memory estimate: 97.75 KiB, allocs estimate: 1333.","category":"page"},{"location":"benchmarks/#Datum:-(3-Kronecker-quiver,-with-adjacency-matrix-[0-3;-0-0],-[2,-3])-2","page":"Benchmarks","title":"Datum: (3-Kronecker quiver, with adjacency matrix [0 3; 0 0], [2, 3])","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"BenchmarkTools.Trial: 10000 samples with 1 evaluation.\n Range (min … max):  67.625 μs …   5.245 ms  ┊ GC (min … max): 0.00% … 97.05%\n Time  (median):     69.500 μs               ┊ GC (median):    0.00%\n Time  (mean ± σ):   76.020 μs ± 170.289 μs  ┊ GC (mean ± σ):  7.32% ±  3.22%\n\n     ▃█▆▃                                                       \n  ▁▂▅█████▅▅▃▃▃▃▃▃▂▂▂▂▂▂▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁ ▂\n  67.6 μs         Histogram: frequency by time         85.7 μs <\n\n Memory estimate: 96.95 KiB, allocs estimate: 1333.","category":"page"},{"location":"benchmarks/#Benchmarking-in_fundamental_domain","page":"Benchmarks","title":"Benchmarking in_fundamental_domain","text":"","category":"section"},{"location":"benchmarks/#Datum:-(5-Kronecker-quiver,-with-adjacency-matrix-[0-5;-0-0],-[2,-3])-3","page":"Benchmarks","title":"Datum: (5-Kronecker quiver, with adjacency matrix [0 5; 0 0], [2, 3])","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"BenchmarkTools.Trial: 10000 samples with 1 evaluation.\n Range (min … max):  15.250 μs …  5.787 ms  ┊ GC (min … max): 0.00% … 98.23%\n Time  (median):     16.000 μs              ┊ GC (median):    0.00%\n Time  (mean ± σ):   16.943 μs ± 57.719 μs  ┊ GC (mean ± σ):  3.36% ±  0.98%\n\n   ▂▄▅▆▇█▇▇▆▆▅▄▄▃▃▃▃▄▄▃▃▂▁▁▁▁     ▁                           ▂\n  ▇████████████████████████████████▇▇██▇▆▇▇▇▇▆▇█████▇██▇▇▅▄▅▆ █\n  15.2 μs      Histogram: log(frequency) by time      20.5 μs <\n\n Memory estimate: 11.45 KiB, allocs estimate: 166.","category":"page"},{"location":"benchmarks/#Datum:-(3-Kronecker-quiver,-with-adjacency-matrix-[0-3;-0-0],-[2,-3])-3","page":"Benchmarks","title":"Datum: (3-Kronecker quiver, with adjacency matrix [0 3; 0 0], [2, 3])","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"BenchmarkTools.Trial: 10000 samples with 1 evaluation.\n Range (min … max):  15.291 μs …  5.627 ms  ┊ GC (min … max): 0.00% … 98.32%\n Time  (median):     15.833 μs              ┊ GC (median):    0.00%\n Time  (mean ± σ):   16.703 μs ± 56.122 μs  ┊ GC (mean ± σ):  3.31% ±  0.98%\n\n      ▇█▁▇▄                                                    \n  ▁▄█▇██████▄▆▄▂▃▂▃▂▃▄▂▄▄▃▂▃▂▂▂▂▂▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁ ▂\n  15.3 μs         Histogram: frequency by time        19.5 μs <\n\n Memory estimate: 11.45 KiB, allocs estimate: 166.","category":"page"},{"location":"methods/#Methods","page":"All methods","title":"Methods","text":"","category":"section"},{"location":"methods/","page":"All methods","title":"All methods","text":"Here are listed all the available methods of QuiverTools","category":"page"},{"location":"methods/","page":"All methods","title":"All methods","text":"Modules = [QuiverTools]","category":"page"},{"location":"methods/#QuiverTools.Quiver","page":"All methods","title":"QuiverTools.Quiver","text":"A quiver is represented by its adjacency n times n matrix adjacency = (a_ij), where n is the number of vertices and a_ij is the number of arrows i to j.\n\nAttributes:\n\nadjacency is the adjacency matrix of the quiver\nname is the name of the quiver, defaults to \"\".\n\n\n\n\n\n","category":"type"},{"location":"methods/#QuiverTools.Betti_numbers-Tuple{QuiverModuliSpace}","page":"All methods","title":"QuiverTools.Betti_numbers","text":"Betti_numbers(M::QuiverModuliSpace)\n\nReturns the Betti numbers of the moduli space M.\n\nINPUT:\n\nM: a moduli space of representations of a quiver.\n\nOUTPUT:\n\na list of Betti numbers of the moduli space.\n\nEXAMPLES:\n\njulia> Q = mKronecker_quiver(2);\n\njulia> M = QuiverModuliSpace(Q, [1, 1]);\n\njulia> Betti_numbers(M)\n3-element Vector{Int64}:\n 1\n 0\n 1\n\nOur favourite 6-fold:\n\njulia> Q = mKronecker_quiver(3);\n\njulia> M = QuiverModuliSpace(Q, [2, 3]);\n\njulia> Betti_numbers(M)\n13-element Vector{Int64}:\n 1\n 0\n 1\n 0\n 3\n 0\n 3\n 0\n 3\n 0\n 1\n 0\n 1\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.CardinalGd-Tuple{AbstractVector{Int64}, Any}","page":"All methods","title":"QuiverTools.CardinalGd","text":"Cardinality of product of general linear groups mathrmGL_d(mathbbF_q).\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.CardinalGl-Tuple{Int64, Any}","page":"All methods","title":"QuiverTools.CardinalGl","text":"Cardinality of general linear group mathrmGL_n(mathbbF_v).\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.CardinalRd-Tuple{Quiver, AbstractVector{Int64}, Any}","page":"All methods","title":"QuiverTools.CardinalRd","text":"Cardinality of representation space mathrmR(Qd) over mathbbF_q.\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.Chern_character_line_bundle-Tuple{QuiverModuliSpace, AbstractVector{Int64}}","page":"All methods","title":"QuiverTools.Chern_character_line_bundle","text":"Chern_character_line_bundle(M::QuiverModuliSpace, eta)\n\nReturns the Chern character of the line bundle L(eta).\n\nINPUT:\n\nM: a moduli space of representations of a quiver.\neta: a choice of linearization for the trivial line bundle.\n\nOUTPUT:\n\nthe Chern character of the line bundle L(eta).\n\nEXAMPLES:\n\nSome line bundles on the projective line:\n\njulia> Q = mKronecker_quiver(2); M = QuiverModuliSpace(Q, [1, 1]);\n\njulia> Chern_character_line_bundle(M, [1, -1])\n-x11 + 1\n\nSome Chern characters for our favourite 6-fold:\n\njulia> Q = mKronecker_quiver(3); M = QuiverModuliSpace(Q, [2, 3]);\n\njulia> Chern_character_line_bundle(M, [3, -2])\n1//720*x21^6 - 1//120*x21^5 + 1//24*x21^4 - 1//6*x21^3 + 1//2*x21^2 - x21 + 1\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.Chern_class_line_bundle-Tuple{QuiverModuliSpace, AbstractVector{Int64}}","page":"All methods","title":"QuiverTools.Chern_class_line_bundle","text":"Chern_class_line_bundle(M::QuiverModuliSpace, eta)\n\nReturns the first Chern class of the line bundle L(eta).\n\nThis is given by L(eta) = bigoplus_i in Q_0 det(U_i)^-eta_i.\n\nINPUT:\n\nM: a moduli space of representations of a quiver.\neta: a choice of linearization for the trivial line bundle.\n\nOUTPUT:\n\nthe first Chern class of the line bundle L(eta) as a polynomial.\n\nEXAMPLES:\n\nThe line bundles mathcalO(i) on the projective line:\n\njulia> Q = mKronecker_quiver(2); M = QuiverModuliSpace(Q, [1, 1]);\n\njulia> l = Chern_class_line_bundle(M, [1, -1])\n-x11\n\nThe line bundle corresponding to the canonical stability condition on our favourite 6-fold:\n\njulia> Q = mKronecker_quiver(3); M = QuiverModuliSpace(Q, [2, 3]);\n\njulia> Chern_class_line_bundle(M, [9, -6])\n-3*x21\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.Chow_ring","page":"All methods","title":"QuiverTools.Chow_ring","text":"Chow_ring(Q, d, theta, a)\n\nComputes the Chow ring of the moduli space of theta-semistable representations of Q with dimension vector d, for a choice of linearization a.\n\nThis method of the function Chow_ring also returns the ambient ring R and the inclusion morphism.\n\nINPUT:\n\nQ: a quiver.\nd: a dimension vector.\ntheta: a stability parameter. Default is the canonical stability.\na: a linearization. Default is the extended gcd of d.\n\nOUTPUT: A tuple containing:\n\nthe Chow ring of the moduli space,\nthe polynomial ring above it,\nthe inclusion map iota  A to R.\n\nEXAMPLES:\n\nThe Chow ring for the projective line has two generators:\n\njulia> Q = mKronecker_quiver(2); M = QuiverModuliSpace(Q, [1, 1]);\n\njulia> CH = Chow_ring(M)[1];\n\njulia> QuiverTools.gens(QuiverTools.quotient_ideal(CH))\n2-element Vector{Singular.spoly{Singular.n_Q}}:\n x21\n x11^2\n\nThe Chow ring for our favourite 6-fold has, in this implementation, 16 generators:\n\njulia> Q = mKronecker_quiver(3); M = QuiverModuliSpace(Q, [2, 3]);\n\njulia> CH = Chow_ring(M)[1]; I = QuiverTools.quotient_ideal(CH);\n\njulia> length(QuiverTools.gens(I))\n16\n\n\n\n\n\n","category":"function"},{"location":"methods/#QuiverTools.Chow_ring-2","page":"All methods","title":"QuiverTools.Chow_ring","text":"Chow_ring(M::QuiverModuliSpace, chi)\n\nComputes the Chow ring of the moduli space M.\n\nINPUT:\n\nM: a moduli space of representations of a quiver.\nchi: a choice of linearization for the trivial line bundle.   It picks one by default if not provided.\n\nOUTPUT:\n\nthe Chow ring of the moduli space.\n\n\n\n\n\n","category":"function"},{"location":"methods/#QuiverTools.Dynkin_quiver-Tuple{String, Int64}","page":"All methods","title":"QuiverTools.Dynkin_quiver","text":"Dynkin_quiver(T, n)\n\nConstructs the Dynkin quiver, with arbitrary orientation of the arrows.\n\nEXAMPLES:\n\njulia> Dynkin_quiver(\"D4\")\nDynkin quiver of type D4, with adjacency matrix [0 1 0 0; 0 0 1 1; 0 0 0 0; 0 0 0 0]\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.Euler_form-Tuple{Quiver, AbstractVector{Int64}, AbstractVector{Int64}}","page":"All methods","title":"QuiverTools.Euler_form","text":"Computes the Euler form of the quiver for vectors x and y.\n\nThe Euler form is defined as the bilinear form\n\nlangle xyrangle = x^T * E * y\n\nwhere E is the Euler matrix of the quiver.\n\nEXAMPLE:\n\njulia> Q = mKronecker_quiver(4);\n\njulia> Euler_form(Q, [1, 1], [1, 1]) == -2\ntrue\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.Euler_matrix-Tuple{Quiver}","page":"All methods","title":"QuiverTools.Euler_matrix","text":"Returns the Euler matrix of the quiver.\n\nThe Euler matrix of a quiver Q is defined as \n\nE = I - A\n\nwhere A is the adjacency matrix of Q and I is the identity matrix of the same size as A.\n\nEXAMPLE:\n\njulia> Q = mKronecker_quiver(4);\n\njulia> QuiverTools.Euler_matrix(Q) == [1 -4; 0 1]\ntrue\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.Hodge_diamond","page":"All methods","title":"QuiverTools.Hodge_diamond","text":"Hodge_diamond(Q, d, theta)\n\nReturns the Hodge diamond of the moduli space of theta-semistable representations of Q with dimension vector d.\n\nINPUT:\n\nQ: a quiver.\nd: a dimension vector.\ntheta: a stability parameter. Default is the canonical stability.\n\nOUTPUT:\n\nthe Hodge diamond of the moduli space.\n\nEXAMPLES:\n\nThe Hodge diamond of our favourite 6-fold:\n\njulia> Q = mKronecker_quiver(3);\n\njulia> Hodge_diamond(Q, [2, 3])\n7×7 Matrix{Int64}:\n 1  0  0  0  0  0  0\n 0  1  0  0  0  0  0\n 0  0  3  0  0  0  0\n 0  0  0  3  0  0  0\n 0  0  0  0  3  0  0\n 0  0  0  0  0  1  0\n 0  0  0  0  0  0  1\n\n\n\n\n\n","category":"function"},{"location":"methods/#QuiverTools.Hodge_diamond-Tuple{QuiverModuli}","page":"All methods","title":"QuiverTools.Hodge_diamond","text":"Hodge_diamond(M::QuiverModuliSpace)\n\nReturns the Hodge diamond of the moduli space M.\n\nINPUT:\n\nM: a moduli space of representations of a quiver.\n\nOUTPUT:\n\nthe Hodge diamond of the moduli space.\n\nEXAMPLES:\n\nThe Hodge diamond of our favourite 6-fold:\n\njulia> Q = mKronecker_quiver(3);\n\njulia> M = QuiverModuliSpace(Q, [2, 3]);\n\njulia> Hodge_diamond(M)\n7×7 Matrix{Int64}:\n 1  0  0  0  0  0  0\n 0  1  0  0  0  0  0\n 0  0  3  0  0  0  0\n 0  0  0  3  0  0  0\n 0  0  0  0  3  0  0\n 0  0  0  0  0  1  0\n 0  0  0  0  0  0  1\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.Hodge_polynomial","page":"All methods","title":"QuiverTools.Hodge_polynomial","text":"Hodge_polynomial(Q, d, theta)\n\nReturns the Hodge polynomial of the moduli space of theta-semistable representations of Q with dimension vector d.\n\nThe algorithm is based on MR1974891, and the current implementation is translated from the Hodge diamond cutter.\n\nINPUT:\n\nQ: a quiver.\nd: a dimension vector.\ntheta: a stability parameter. Default is the canonical stability.\n\nOUTPUT:\n\nthe Hodge polynomial of the moduli space.\n\nEXAMPLES:\n\nThe Hodge polynomial of our favourite 6-fold:\n\njulia> Q = mKronecker_quiver(3);\n\njulia> d = [2, 3];\n\njulia> theta = [3, -2];\n\njulia> Hodge_polynomial(Q, d, theta)\nx^6*y^6 + x^5*y^5 + 3*x^4*y^4 + 3*x^3*y^3 + 3*x^2*y^2 + x*y + 1\n\n\n\n\n\n","category":"function"},{"location":"methods/#QuiverTools.Hodge_polynomial-Tuple{QuiverModuliSpace}","page":"All methods","title":"QuiverTools.Hodge_polynomial","text":"Hodge_polynomial(M::QuiverModuliSpace)\n\nReturns the Hodge polynomial of the moduli space M.\n\nINPUT:\n\nM: a moduli space of representations of a quiver.\n\nOUTPUT:\n\nthe Hodge polynomial of the moduli space.\n\nEXAMPLES:\n\nThe Hodge polynomial of our favourite 6-fold:\n\njulia> Q = mKronecker_quiver(3);\n\njulia> M = QuiverModuliSpace(Q, [2, 3]);\n\njulia> Hodge_polynomial(M)\nx^6*y^6 + x^5*y^5 + 3*x^4*y^4 + 3*x^3*y^3 + 3*x^2*y^2 + x*y + 1\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.Picard_rank-Tuple{QuiverModuliSpace}","page":"All methods","title":"QuiverTools.Picard_rank","text":"Picard_rank(M::QuiverModuliSpace)\n\nReturns the Picard rank of the moduli space M.\n\nINPUT:\n\nM: a moduli space of representations of a quiver.\n\nOUTPUT:\n\nthe Picard rank of the moduli space.\n\nEXAMPLES:\n\nKronecker quiver with dimension vector [2, 3]:\n\njulia> Q = mKronecker_quiver(3);\n\njulia> M = QuiverModuliSpace(Q, [2, 3]);\n\njulia> Picard_rank(M)\n1\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.Poincare_polynomial-Tuple{QuiverModuliSpace}","page":"All methods","title":"QuiverTools.Poincare_polynomial","text":"Poincare_polynomial(M::QuiverModuliSpace)\n\nReturns the Poincaré polynomial of the moduli space M.\n\nINPUT:\n\nM: a moduli space of representations of a quiver.\n\nOUTPUT:\n\nthe Poincaré polynomial of the moduli space.\n\nEXAMPLES:\n\nA Kronecker quiver setup where M is the projective line:\n\njulia> Q = mKronecker_quiver(2);\n\njulia> M = QuiverModuliSpace(Q, [1, 1]);\n\njulia> Poincare_polynomial(M)\nL + 1\n\nThe Poincaré polynomial of our favourite 6-fold:\n\njulia> Q = mKronecker_quiver(3);\n\njulia> M = QuiverModuliSpace(Q, [2, 3]);\n\njulia> Poincare_polynomial(M)\nL^6 + L^5 + 3*L^4 + 3*L^3 + 3*L^2 + L + 1\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.Teleman_bound_onstratum","page":"All methods","title":"QuiverTools.Teleman_bound_onstratum","text":"Computes the weight on det(N_SR_Z) of the 1-PS lambda corresponding to the given HN type.\n\n\n\n\n\n","category":"function"},{"location":"methods/#QuiverTools.Todd_class","page":"All methods","title":"QuiverTools.Todd_class","text":"todd_class(M::QuiverModuliSpace, chi)\n\nReturns the Todd class of the moduli space M.\n\nINPUT:\n\nM: a moduli space of representations of a quiver.\nchi: a choice of linearization to construct the universal bundles.\n\nOUTPUT:\n\nthe Todd class of the moduli space, as a polynomial in its Chow ring.\n\nEXAMPLES: The Todd class of our favourite 3-Kronecker quiver moduli:\n\njulia> Q = mKronecker_quiver(3); M = QuiverModuliSpace(Q, [2, 3]);\n\njulia> Todd_class(M)\n-17//8*x12*x21 + x21^2 + 823//360*x12*x22 - 823//1080*x22^2 + 553//1080*x21*x23 - 77//60*x22*x23 + x23^2 + 5//12*x12 - 3//2*x21 + 9//8*x23 + 1\n\n\n\n\n\n","category":"function"},{"location":"methods/#QuiverTools.TransferMatrixEntry-NTuple{4, Any}","page":"All methods","title":"QuiverTools.TransferMatrixEntry","text":"Entry of the transfer matrix, as per Corollary 6.9 of MR1974891\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.__Chow_degrees-Tuple{AbstractVector{Int64}}","page":"All methods","title":"QuiverTools.__Chow_degrees","text":"__Chow_degrees(d)\n\nReturns the vector of degrees for the variables of a Chow ring.\n\nFor internal use only.\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.__Chow_ring_monomial_grading-Tuple{QuiverModuliSpace, Any}","page":"All methods","title":"QuiverTools.__Chow_ring_monomial_grading","text":"__Chow_ring__monomial_grading(M, f)\n\nReturns the \"pseudodegree\" of the monomial f in the Chow ring of the moduli space M passed.\n\nThis method is unsafe, as it does not consider the actual degree of the MPolyRingElem objects passed. Instead, it assumes that the Chow ring passed has variables x_i j as in the Chow ring paper.\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.all_HN_types","page":"All methods","title":"QuiverTools.all_HN_types","text":"all_HN_types(Q, d, theta, denom, ordered=true)\n\nReturns a list of all the Harder Narasimhan types of representations of Q with dimension vector d, with respect to the slope function theta/denom.\n\nEXAMPLES:\n\njulia> Q = mKronecker_quiver(3); d = [2,3]; theta = [3,-2];\n\njulia> all_HN_types(Q, d, theta)\n8-element Vector{Vector{AbstractVector{Int64}}}:\n [[2, 3]]\n [[1, 1], [1, 2]]\n [[2, 2], [0, 1]]\n [[2, 1], [0, 2]]\n [[1, 0], [1, 3]]\n [[1, 0], [1, 2], [0, 1]]\n [[1, 0], [1, 1], [0, 2]]\n [[2, 0], [0, 3]]\n\njulia> all_HN_types(Q, [3,0], [0,0])\n1-element Vector{Vector{AbstractVector{Int64}}}:\n [[3, 0]]\n\njulia> Q = three_vertex_quiver(1, 4, 1); d = [4, 1, 4];\n\njulia> theta = canonical_stability(Q, d);\n\njulia> all_HN_types(Q, d, theta)\n106-element Vector{Vector{AbstractVector{Int64}}}:\n [[4, 1, 4]]\n [[4, 1, 3], [0, 0, 1]]\n [[4, 0, 3], [0, 1, 1]]\n [[4, 0, 3], [0, 1, 0], [0, 0, 1]]\n [[3, 1, 2], [1, 0, 2]]\n [[3, 1, 2], [1, 0, 1], [0, 0, 1]]\n [[3, 0, 2], [1, 1, 2]]\n [[3, 0, 2], [0, 1, 0], [1, 0, 2]]\n [[3, 0, 2], [1, 0, 1], [0, 1, 1]]\n [[3, 0, 2], [1, 1, 1], [0, 0, 1]]\n ⋮\n [[3, 0, 0], [1, 1, 2], [0, 0, 2]]\n [[3, 0, 0], [0, 1, 0], [1, 0, 4]]\n [[3, 0, 0], [0, 1, 0], [1, 0, 3], [0, 0, 1]]\n [[3, 0, 0], [0, 1, 0], [1, 0, 2], [0, 0, 2]]\n [[3, 0, 0], [1, 0, 1], [0, 1, 1], [0, 0, 2]]\n [[3, 0, 0], [1, 1, 1], [0, 0, 3]]\n [[3, 0, 0], [1, 1, 0], [0, 0, 4]]\n [[4, 0, 0], [0, 1, 1], [0, 0, 3]]\n [[4, 0, 0], [0, 1, 0], [0, 0, 4]]\n\n\n\n\n\n","category":"function"},{"location":"methods/#QuiverTools.all_HN_types-Tuple{QuiverModuli}","page":"All methods","title":"QuiverTools.all_HN_types","text":"all_HN_types(M::QuiverModuli; unstable::Bool = false, ordered::Bool = true)\n\nReturns all Harder-Narasimhan types of the moduli space.\n\nINPUT:\n\nM::QuiverModuli: a moduli space or stack of representations of a quiver.\nunstable::Bool = false: if true, returns only Harder-Narasimhan types\n\ncorresponding to unstable representations.\n\nordered::Bool = true: if true, returns the Harder-Narasimhan types in\n\nthe order introduced by MR1974891.\n\nOUTPUT:\n\na list of Harder-Narasimhan types for the dimension vector and slope of M.\n\nEXAMPLES:\n\nThe HN types for a 3-Kronecker quiver with dimension vector [2, 3]:\n\njulia> Q = mKronecker_quiver(3); M = QuiverModuliSpace(Q, [2, 3]);\n\njulia> all_HN_types(M)\n8-element Vector{Vector{AbstractVector{Int64}}}:\n [[2, 3]]\n [[1, 1], [1, 2]]\n [[2, 2], [0, 1]]\n [[2, 1], [0, 2]]\n [[1, 0], [1, 3]]\n [[1, 0], [1, 2], [0, 1]]\n [[1, 0], [1, 1], [0, 2]]\n [[2, 0], [0, 3]]\n\njulia> all_HN_types(M, unstable = true)\n7-element Vector{Vector{AbstractVector{Int64}}}:\n [[1, 1], [1, 2]]\n [[2, 2], [0, 1]]\n [[2, 1], [0, 2]]\n [[1, 0], [1, 3]]\n [[1, 0], [1, 2], [0, 1]]\n [[1, 0], [1, 1], [0, 2]]\n [[2, 0], [0, 3]]\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.all_Luna_types","page":"All methods","title":"QuiverTools.all_Luna_types","text":"all_Luna_types(Q, d, theta, denom, exclude_stable)\n\nComputes all the possible Luna types for the given data.\n\nINPUT:\n\nQ: a quiver.\nd: a dimension vector.\ntheta: a stability parameter. Defaults to the canonical stability.\ndenom: a function defining the denominator of the slope. Defaults to sum.\nexclude_stable: whether to exclude the Luna type of stable representations.\n\nOUTPUT: A list of Luna types.\n\nEXAMPLES:\n\njulia> Q = mKronecker_quiver(3); M = QuiverModuliSpace(Q, [3, 3]);\n\njulia> all_Luna_types(M)\n5-element Vector{Dict{AbstractVector, Vector{Int64}}}:\n Dict([3, 3] => [1])\n Dict([1, 1] => [1], [2, 2] => [1])\n Dict([1, 1] => [3])\n Dict([1, 1] => [2, 1])\n Dict([1, 1] => [1, 1, 1])\n\njulia> X = QuiverModuliSpace(Q, [2, 3]);\n\njulia> all_Luna_types(X)\n1-element Vector{Dict{AbstractVector, Vector{Int64}}}:\n Dict([2, 3] => [1])\n\n\n\n\n\n","category":"function"},{"location":"methods/#QuiverTools.all_Luna_types-Tuple{QuiverModuli}","page":"All methods","title":"QuiverTools.all_Luna_types","text":"all_Luna_types(M::QuiverModuli; exclude_stable::Bool = false)\n\nReturns all Luna types of the moduli space.\n\nINPUT:\n\nM::QuiverModuli: a moduli space or stack of representations of a quiver.\nexclude_stable::Bool = false: if true, excludes the stable Luna type.\n\nOUTPUT:\n\na list of Luna types for the dimension vector and slope of M.\n\nEXAMPLES:\n\nLuna types for a 3-Kronecker quiver:\n\njulia> Q = mKronecker_quiver(3); M = QuiverModuliSpace(Q, [3, 3]);\n\njulia> all_Luna_types(M)\n5-element Vector{Dict{AbstractVector, Vector{Int64}}}:\n Dict([3, 3] => [1])\n Dict([1, 1] => [1], [2, 2] => [1])\n Dict([1, 1] => [3])\n Dict([1, 1] => [2, 1])\n Dict([1, 1] => [1, 1, 1])\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.all_Teleman_bounds","page":"All methods","title":"QuiverTools.all_Teleman_bounds","text":"Computes the weight on det(N_SR_Z) of the 1-PS corresponding to each HN type for the given Q, d, theta and denom`.\n\nEXAMPLES:\n\njulia> Q = mKronecker_quiver(3);\n\njulia> all_Teleman_bounds(Q, [2, 3], [3, -2])\nDict{Vector{AbstractVector{Int64}}, Int64} with 7 entries:\n  [[2, 2], [0, 1]]         => 20\n  [[2, 1], [0, 2]]         => 100\n  [[1, 0], [1, 2], [0, 1]] => 100\n  [[1, 0], [1, 3]]         => 120\n  [[1, 0], [1, 1], [0, 2]] => 90\n  [[1, 1], [1, 2]]         => 15\n  [[2, 0], [0, 3]]         => 90\n\n\n\n\n\n","category":"function"},{"location":"methods/#QuiverTools.all_Teleman_bounds-Tuple{QuiverModuli}","page":"All methods","title":"QuiverTools.all_Teleman_bounds","text":"Interface for all_Teleman_bounds(Q, d, theta).\n\nEXAMPLE:\n\njulia> Q = three_vertex_quiver(1, 2, 3); d = [3, 1, 2]; theta = [5, 3, -9];\n\njulia> all_Teleman_bounds(Q, d, theta)\nDict{Vector{AbstractVector{Int64}}, Int64} with 24 entries:\n  [[2, 1, 1], [1, 0, 1]]                       => 12\n  [[1, 0, 0], [0, 1, 0], [2, 0, 1], [0, 0, 1]] => 306\n  [[1, 0, 0], [1, 1, 0], [1, 0, 1], [0, 0, 1]] => 131\n  [[2, 0, 0], [1, 0, 1], [0, 1, 1]]            => 64\n  [[3, 0, 0], [0, 1, 2]]                       => 150\n  [[1, 1, 0], [2, 0, 1], [0, 0, 1]]            => 312\n  [[2, 0, 0], [1, 1, 1], [0, 0, 1]]            => 336\n  [[2, 0, 0], [1, 1, 0], [0, 0, 2]]            => 242\n  [[3, 0, 0], [0, 1, 1], [0, 0, 1]]            => 168\n  [[3, 1, 1], [0, 0, 1]]                       => 432\n  [[3, 0, 0], [0, 1, 0], [0, 0, 2]]            => 246\n  [[0, 1, 0], [3, 0, 2]]                       => 108\n  [[0, 1, 0], [2, 0, 1], [1, 0, 1]]            => 76\n  [[1, 0, 0], [2, 0, 1], [0, 1, 1]]            => 122\n  [[1, 0, 0], [2, 1, 1], [0, 0, 1]]            => 92\n  [[2, 0, 0], [0, 1, 0], [1, 0, 2]]            => 312\n  [[1, 0, 0], [2, 1, 2]]                       => 18\n  [[2, 0, 0], [0, 1, 0], [1, 0, 1], [0, 0, 1]] => 132\n  [[1, 0, 0], [1, 1, 1], [1, 0, 1]]            => 68\n  ⋮                                            => ⋮\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.all_destabilizing_subdimension_vectors","page":"All methods","title":"QuiverTools.all_destabilizing_subdimension_vectors","text":"Returns the subdimension vectors of d with a strictly larger slope than d.\n\n\n\n\n\n","category":"function"},{"location":"methods/#QuiverTools.all_generic_subdimension_vectors-Tuple{Quiver, AbstractVector{Int64}}","page":"All methods","title":"QuiverTools.all_generic_subdimension_vectors","text":"Returns the list of all generic subdimension vectors of d.\n\nEXAMPLES:\n\njulia> Q = mKronecker_quiver(3);\n\njulia> QuiverTools.all_generic_subdimension_vectors(Q, [2, 3])\n7-element Vector{AbstractVector{Int64}}:\n [0, 0]\n [0, 1]\n [0, 2]\n [1, 2]\n [0, 3]\n [1, 3]\n [2, 3]\n\njulia> QuiverTools.all_generic_subdimension_vectors(Q, [3, 0])\n4-element Vector{AbstractVector{Int64}}:\n [0, 0]\n [1, 0]\n [2, 0]\n [3, 0]\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.all_slope_decreasing_sequences","page":"All methods","title":"QuiverTools.all_slope_decreasing_sequences","text":"Returns the list of all sequences (d^1d^l) which sum to d such that mu(d^1)    mu(d^l)\n\nEXAMPLES:\n\njulia> Q = mKronecker_quiver(3); d = [2,3]; theta = [3,-2];\n\njulia> QuiverTools.all_slope_decreasing_sequences(Q, d, theta)\n8-element Vector{Vector{AbstractVector{Int64}}}:\n [[2, 3]]\n [[1, 1], [1, 2]]\n [[2, 2], [0, 1]]\n [[2, 1], [0, 2]]\n [[1, 0], [1, 3]]\n [[1, 0], [1, 2], [0, 1]]\n [[1, 0], [1, 1], [0, 2]]\n [[2, 0], [0, 3]]\n\n\n\n\n\n","category":"function"},{"location":"methods/#QuiverTools.all_subdimension_vectors-Tuple{AbstractVector{Int64}}","page":"All methods","title":"QuiverTools.all_subdimension_vectors","text":"all_subdimension_vectors(d::AbstractVector{Int})\n\nCompute all subdimension vectors of a given dimension vector d.\n\nINPUT:\n\nd::AbstractVector{Int}: The input dimension vector.\nnonzero::Bool=false: wether to exclude the zero vector.\nstrict::Bool=false: wether to exclude the input vector d.\n\nOUTPUT:\n\nAn array of all subdimension vectors of d, with or without the zero vector and d.\n\nEXAMPLES:\n\njulia> QuiverTools.all_subdimension_vectors([2, 3])\n12-element Vector{AbstractVector{Int64}}:\n [0, 0]\n [1, 0]\n [2, 0]\n [0, 1]\n [1, 1]\n [2, 1]\n [0, 2]\n [1, 2]\n [2, 2]\n [0, 3]\n [1, 3]\n [2, 3]\n\njulia> QuiverTools.all_subdimension_vectors([2, 3], nonzero=true)\n11-element Vector{AbstractVector{Int64}}:\n [1, 0]\n [2, 0]\n [0, 1]\n [1, 1]\n [2, 1]\n [0, 2]\n [1, 2]\n [2, 2]\n [0, 3]\n [1, 3]\n [2, 3]\n\njulia> QuiverTools.all_subdimension_vectors([2, 3], nonzero=true, strict=true)\n10-element Vector{AbstractVector{Int64}}:\n [1, 0]\n [2, 0]\n [0, 1]\n [1, 1]\n [2, 1]\n [0, 2]\n [1, 2]\n [2, 2]\n [0, 3]\n [1, 3]\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.all_weights_endomorphisms_universal_bundle","page":"All methods","title":"QuiverTools.all_weights_endomorphisms_universal_bundle","text":"Computes the weights of the endomorphisms of the universal bundles U_i otimes U_j on all the non-dense Harder-Narasimhan strata for each 1-PS relative to the HN type.\n\n\n\n\n\n","category":"function"},{"location":"methods/#QuiverTools.all_weights_irreducible_component_canonical","page":"All methods","title":"QuiverTools.all_weights_irreducible_component_canonical","text":"Computes the weights of the irreducible component of omega_R_Z on all the non-dense Harder-Narasimhan strata for each 1-PS relative to the HN type. More explicitly, if omega_X = O(rH), this returns the weights of the pullback of mathcalO(H) on each stratum.\n\n\n\n\n\n","category":"function"},{"location":"methods/#QuiverTools.all_weights_universal_bundle","page":"All methods","title":"QuiverTools.all_weights_universal_bundle","text":"Computes the weights of the universal bundle U_i(a) for the linearization a on all the non-dense Harder-Narasimhan strata for each 1-PS corresponding to each HN type.\n\n\n\n\n\n","category":"function"},{"location":"methods/#QuiverTools.arrows-Tuple{Quiver}","page":"All methods","title":"QuiverTools.arrows","text":"arrows(Q::Quiver)\n\nReturns a list of all arrows of the quiver Q.\n\nINPUT:\n\nQ: a quiver\n\nOUTPUT:\n\na list of all arrows of the quiver Q.\n\nEXAMPLES:\n\njulia> Q = mKronecker_quiver(3);\n\njulia> arrows(Q)\n3-element Vector{Vector{Int64}}:\n [1, 2]\n [1, 2]\n [1, 2]\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.bipartite_quiver-Tuple{Int64, Int64}","page":"All methods","title":"QuiverTools.bipartite_quiver","text":"bipartite_quiver(m, n)\n\nConstructs the bipartite quiver on m and n vertices.\n\nEXAMPLES:\n\njulia> bipartite_quiver(2, 3).adjacency\n5×5 Matrix{Int64}:\n 0  0  1  1  1\n 0  0  1  1  1\n 0  0  0  0  0\n 0  0  0  0  0\n 0  0  0  0  0\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.canonical_decomposition-Tuple{Quiver, AbstractVector{Int64}}","page":"All methods","title":"QuiverTools.canonical_decomposition","text":"Computes the canonical decomposition of the dimension vector d for the given quiver Q.\n\nIf beta_1 dots beta_ell is a sequence of Schur roots such that, for all i neq j, one has\n\nmathrmext(beta_i beta_j) = mathrmext(beta_j beta_i) = 0\n\nthen the general representation of dimension sum_i beta_i is isomorphic to the direct sum of irreducible representations of dimension vectors beta_i.\n\nSuch a decomposition is called the canonical decomposition.\n\nEXAMPLES:\n\njulia> Q = mKronecker_quiver(3);\n\njulia> canonical_decomposition(Q, [6, 7]) == [[6, 7]]\ntrue\n\njulia> canonical_decomposition(Q, [1, 1]) == [[1, 1]]\ntrue\n\njulia> canonical_decomposition(Q, [6, 2]) == [[3, 1], [3, 1]]\ntrue\n\njulia> Q = mKronecker_quiver(2);\n\njulia> canonical_decomposition(Q, [8, 8]) == [[1, 1] for i in 1:8]\ntrue\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.canonical_stability-Tuple{Quiver, AbstractVector{Int64}}","page":"All methods","title":"QuiverTools.canonical_stability","text":"The canonical stability parameter for the couple (Q d) is given by d- - -d\n\nINPUT:\n\nQ: a quiver\nd: a dimension vector\n\nOUTPUT:\n\nthe canonical stability parameter for the couple (Q d)\n\nEXAMPLES:\n\njulia> Q = mKronecker_quiver(3); d = [2,3];\n\njulia> canonical_stability(Q, d) == [9, -6]\ntrue\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.codimension_HN_stratum-Tuple{Quiver, Vector{<:AbstractVector{Int64}}}","page":"All methods","title":"QuiverTools.codimension_HN_stratum","text":"Returns the codimension of the given HN stratum.\n\nEXAMPLES:\n\njulia> Q = mKronecker_quiver(3); d = [2,3]; theta = [3,-2];\n\njulia> HN = all_HN_types(Q, d, theta)\n8-element Vector{Vector{AbstractVector{Int64}}}:\n [[2, 3]]\n [[1, 1], [1, 2]]\n [[2, 2], [0, 1]]\n [[2, 1], [0, 2]]\n [[1, 0], [1, 3]]\n [[1, 0], [1, 2], [0, 1]]\n [[1, 0], [1, 1], [0, 2]]\n [[2, 0], [0, 3]]\n\njulia> [codimension_HN_stratum(Q, stratum) for stratum in HN]\n8-element Vector{Int64}:\n  0\n  3\n  4\n 10\n  8\n  9\n 12\n 18\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.codimension_HN_stratum-Tuple{QuiverModuli, Vector{<:AbstractVector{Int64}}}","page":"All methods","title":"QuiverTools.codimension_HN_stratum","text":"codimension_HN_stratum(M::QuiverModuli, hn_type::Vector{<AbstractVector{Int}})\n\nComputes the codimension of the Harder-Narasimhan stratum corresponding to the given HN type.\n\nINPUT:\n\nM::QuiverModuli: a moduli space or stack of representations of a quiver.\nhn_type::Vector{<:AbstractVector{Int}}: a HN type for M.\n\nOUTPUT:\n\nthe codimension of the Harder-Narasimhan stratum corresponding to the given HN type.\n\nEXAMPLES:\n\nCodimensions for the 3-Kronecker quiver with dimension vector [2, 3]:\n\njulia> Q = mKronecker_quiver(3); M = QuiverModuliSpace(Q, [2, 3]);\n\njulia> codimension_HN_stratum(M, [[2, 3]])\n0\n\njulia> codimension_HN_stratum(M, [[1, 1], [1, 2]])\n3\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.codimension_unstable_locus-Tuple{QuiverModuli}","page":"All methods","title":"QuiverTools.codimension_unstable_locus","text":"codimension_unstable_locus(M::QuiverModuli)\n\nComputes the codimension of the unstable locus in the parameter space.\n\nINPUT:\n\nM::QuiverModuli: a moduli space or stack of representations of a quiver.\n\nOUTPUT:\n\nthe codimension of the unstable locus in the parameter space.\n\nEXAMPLES:\n\nCodimensions for the 3-Kronecker quiver with dimension vector [2, 3]:\n\njulia> Q = mKronecker_quiver(3); M = QuiverModuliSpace(Q, [2, 3]);\n\njulia> codimension_unstable_locus(M)\n3\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.coerce_to_quotient-Tuple{Any, Any}","page":"All methods","title":"QuiverTools.coerce_to_quotient","text":"Takes a quotient ring R/I and a polynomial f in R and returns the image of f in R/I.\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.cyclic_quiver-Tuple{Int64}","page":"All methods","title":"QuiverTools.cyclic_quiver","text":"cyclic_quiver(n)\n\nReturns a cyclic quiver on n vertices.\n\nEXAMPLES:\n\njulia> cyclic_quiver(4)\ncyclic quiver on 4 vertices, with adjacency matrix [0 1 0 0; 0 0 1 0; 0 0 0 1; 1 0 0 0]\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.dimension-Tuple{QuiverModuliSpace}","page":"All methods","title":"QuiverTools.dimension","text":"dimension(M::QuiverModuliSpace)\n\nReturns the dimension of the moduli space.\n\nINPUT:\n\nM: a moduli space of representations of a quiver.\n\nOUTPUT:\n\nthe dimension of the moduli space.\n\nEXAMPLES:\n\nThe dimension of the moduli space of the 3-Kronecker quiver:\n\njulia> Q = mKronecker_quiver(3); M = QuiverModuliSpace(Q, [2, 3]);\n\njulia> dimension(M)\n6\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.dimension-Tuple{QuiverModuliStack}","page":"All methods","title":"QuiverTools.dimension","text":"dimension(M::QuiverModuliStack)\n\nReturns the dimension of the moduli stack. This differs from the dimension of the moduli space by 1, as we do not quotient out the stabilizer mathbbG.\n\nINPUT:\n\nM: a moduli stack of representations of a quiver.\n\nOUTPUT:\n\nthe dimension of the moduli stack.\n\nEXAMPLES:\n\nThe dimension of the moduli stack of the 3-Kronecker quiver\n\njulia> Q = mKronecker_quiver(3); M = QuiverModuliStack(Q, [2, 3]);\n\njulia> dimension(M)\n5\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.dimension_of_Luna_stratum-Tuple{QuiverModuli, Any}","page":"All methods","title":"QuiverTools.dimension_of_Luna_stratum","text":"dimension_of_Luna_stratum(M::QuiverModuli, tau)\n\nComputes the dimension of the Luna stratum corresponding to the given Luna type in the moduli space.\n\nINPUT:\n\nM::QuiverModuli: a moduli space or stack of representations of a quiver.\ntau::Dict{AbstractVector{Int}, Vector{Int}}: a Luna type for M.\n\nOUTPUT:\n\nthe dimension of the Luna stratum corresponding to the given Luna type.\n\nEXAMPLES:\n\njulia> Q = mKronecker_quiver(2); M = QuiverModuliSpace(Q, [2, 2], [1, -1]);\n\njulia> luna = all_Luna_types(M)\n2-element Vector{Dict{AbstractVector, Vector{Int64}}}:\n Dict([1, 1] => [2])\n Dict([1, 1] => [1, 1])\n\njulia> [dimension_of_Luna_stratum(M, tau) for tau in luna]\n2-element Vector{Int64}:\n 1\n 2\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.does_Teleman_inequality_hold-Tuple{QuiverModuli}","page":"All methods","title":"QuiverTools.does_Teleman_inequality_hold","text":"does_Teleman_inequality_hold(M::QuiverModuli)\n\nChecks if the Teleman quantization criterion of arXiv:2311.17003 holds.\n\nIn case the quiver is acyclic, this ensures that the moduli space is infinitesimally rigid.\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.double_quiver-Tuple{Quiver}","page":"All methods","title":"QuiverTools.double_quiver","text":"The adjacency matrix of the double of a quiver is the sum of the adjacency matrix of the original quiver and its transpose.\n\nEXAMPLES:\n\njulia> Q = mKronecker_quiver();\n\njulia> double_quiver(Q)\ndouble of 2-Kronecker quiver, with adjacency matrix [0 2; 2 0]\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.extended_gcd-Tuple{Any}","page":"All methods","title":"QuiverTools.extended_gcd","text":"Computes the gcd and the Bezout coefficients of a list of integers.\n\nINPUT:\n\nx: a list of integers.\n\nOUTPUT: A tuple containing:\n\nthe gcd of the integers,\na choice of Bezout coefficients.\n\nEXAMPLES:\n\njulia> QuiverTools.extended_gcd([2, 3, 4])\n2-element Vector{Any}:\n 1\n  [-1, 1, 0]\n  \njulia> QuiverTools.extended_gcd([2, 3])\n2-element Vector{Any}:\n 1\n  [-1, 1]\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.generic_ext-Tuple{Quiver, AbstractVector{Int64}, AbstractVector{Int64}}","page":"All methods","title":"QuiverTools.generic_ext","text":"Computes the dimension of the mathrmExt^1 group between generic representations of dimension vectors a and b.\n\nAccording to Theorem 5.4, MR1162487, we have\n\next(ab)=max-langle cbranglectextis a generic subdimension vector of a\n\nEXAMPLES:\n\njulia> Q1 = mKronecker_quiver(3);\n\njulia> generic_ext(Q1, [2, 3], [6, 7])\n9\n\njulia> generic_ext(Q1, [1, 1], [1, 0])\n0\n\njulia> Q2 = three_vertex_quiver(1, 6, 7);\n\njulia> generic_ext(Q2, [5, 6, 7], [6, 7, 8])\n483\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.generic_hom-Tuple{Quiver, AbstractVector{Int64}, AbstractVector{Int64}}","page":"All methods","title":"QuiverTools.generic_hom","text":"Computes the dimension of the mathrmHom group between generic representations of dimension vectors a and b.\n\nEXAMPLES:\n\njulia> Q1 = mKronecker_quiver(3);\n\njulia> generic_hom(Q1, [2, 3], [6, 7])\n0\n\njulia> generic_hom(Q1, [1, 1], [1, 0])\n1\n\njulia> Q2 = three_vertex_quiver(1, 6, 7);\n\njulia> generic_hom(Q2, [5, 6, 7], [6, 7, 8])\n0\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.has_semistables","page":"All methods","title":"QuiverTools.has_semistables","text":"Checks if there is a theta-semistable representation of dimension vector d.\n\nEXAMPLES:\n\njulia> A2 = mKronecker_quiver(1); theta = [1,-1];\n\njulia> has_semistables(A2, [1,1], theta)\ntrue\n\njulia> has_semistables(A2, [2,2], theta)\ntrue\n\njulia> has_semistables(A2, [1,2], theta)\nfalse\n\njulia> has_semistables(A2, [0,0], theta)\ntrue\n\nThe 3-Kronecker quiver:\n\njulia> K3 = mKronecker_quiver(3); theta = [3,-2];\n\njulia> has_semistables(K3, [2,3], theta)\ntrue\n\njulia> has_semistables(K3, [1,4], theta)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"methods/#QuiverTools.has_stables","page":"All methods","title":"QuiverTools.has_stables","text":"Checks if Q has a theta-stable representation of dimension vector d.\n\nEXAMPLES:\n\njulia> Q = mKronecker_quiver(3); d = [2, 3]; theta = [3, -2];\n\njulia> has_stables(Q, d, theta)\ntrue\n\njulia> Q = mKronecker_quiver(2); d = [2,2]; theta = [1,-1];\n\njulia> has_stables(Q, d, theta)\nfalse\n\njulia> has_semistables(Q, d, theta)\ntrue\n\nThe zero dimension vector has no stables:\n\njulia> Q = mKronecker_quiver(3); d = [0,0];\n\njulia> has_stables(Q, d)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"methods/#QuiverTools.identity_matrix-Tuple{Int64}","page":"All methods","title":"QuiverTools.identity_matrix","text":"Returns the identity matrix of size n.\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.in_fundamental_domain-Tuple{Quiver, AbstractVector{Int64}}","page":"All methods","title":"QuiverTools.in_fundamental_domain","text":"Checks if the dimension vector d is in the fundamental domain of the quiver Q.\n\nThe fundamental domain is the cone of dimension vectors in mathbbZ^Q_0 such that the symmetric Tits form is negative on all the simple roots, i.e., for all vertices i,\n\n(s_i d) = langle d s_irangle + langle s_i drangle  leq 0\n\nwhere s_i is the dimension vector with all entries set to 0 and the i-th set to 1.\n\nEXAMPLES:\n\njulia> Q = mKronecker_quiver(3);\n\njulia> in_fundamental_domain(Q, [2, 3])\ntrue\n\njulia> in_fundamental_domain(Q, [1, 1])\ntrue\n\njulia> in_fundamental_domain(Q, [2, 2])\ntrue\n\njulia> in_fundamental_domain(Q, [1, 2])\nfalse\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.indegree-Tuple{Quiver, Int64}","page":"All methods","title":"QuiverTools.indegree","text":"Returns the number of incoming arrows to the vertex j.\n\nEXAMPLES:\n\njulia> Q = mKronecker_quiver(4);\n\njulia> indegree(Q, 1)\n0\n\njulia> indegree(Q, 2)\n4\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.index-Tuple{QuiverModuliSpace}","page":"All methods","title":"QuiverTools.index","text":"index(M::QuiverModuliSpace)\n\nReturns the index of the moduli space M.\n\nThe index of a variety X is the largest which divides the canonical divisor K_X in Pic(X).\n\nThis implementation currently only works for the canonical stability.\n\nINPUT:\n\nM: a moduli space of representations of a quiver.\n\nOUTPUT:\n\nthe index of the moduli space.\n\nEXAMPLES:\n\nThe 3-Kronecker quiver has index 3:\n\njulia> Q = mKronecker_quiver(3);\n\njulia> M = QuiverModuliSpace(Q, [2, 3]);\n\njulia> index(M)\n3\n\nThe subspace quiver moduli have index 1:\n\njulia> Q = subspace_quiver(5);\n\njulia> M = QuiverModuliSpace(Q, [1, 1, 1, 1, 1, 2]);\n\njulia> index(M)\n1\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.integral","page":"All methods","title":"QuiverTools.integral","text":"integral(M, f, chi)\n\nComputes the integral of f according to the Hirzebruch-Riemann-Roch theorem.\n\nIn other words, it computes the Euler characteristic of the vector bundle whose Chern character is f.\n\nINPUT:\n\nM: a moduli space of representations of a quiver.\nf: the Chern character in CH(M) to integrate.\nchi: a choice of linearization to construct the universal bundles.\n\nOUTPUT: the integral of f.\n\nEXAMPLES:\n\nThe integral of mathcalO(i) on the projective line for some is.\n\njulia> Q = mKronecker_quiver(2); M = QuiverModuliSpace(Q, [1, 1]);\n\njulia> L = Chern_character_line_bundle(M, [1, -1]);\n\njulia> [integral(M, L^i) for i in 0:5]\n6-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n 6\n\nHilbert series for the 3-Kronecker quiver as in our favourite 6-fold:\n\njulia> Q = mKronecker_quiver(3); M = QuiverModuliSpace(Q, [2, 3]);\n\njulia> L = Chern_character_line_bundle(M, [3, -2]);\n\njulia> [integral(M, L^i) for i in 0:5]\n6-element Vector{Int64}:\n    1\n   20\n  148\n  664\n 2206\n 5999\n\n\n\n\n\n","category":"function"},{"location":"methods/#QuiverTools.is_HN_type","page":"All methods","title":"QuiverTools.is_HN_type","text":"is_hn_type(Q, d, dstar, theta, denom)\n\nChecks if the given ordered list of subdimension vectors dstar is an HN type for the datum (Q d) and the slope stability given by (theta denom).\n\nEXAMPLES:\n\njulia> Q = mKronecker_quiver(3);\n\njulia> d = [2, 3]; dstar = [d];\n\njulia> is_HN_type(Q, d, dstar)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"methods/#QuiverTools.is_HN_type-Tuple{QuiverModuli, Vector{<:AbstractVector{Int64}}}","page":"All methods","title":"QuiverTools.is_HN_type","text":"is_HN_type(M::QuiverModuli, hn_type::AbstractVector{<:AbstractVector{Int}})\n\nChecks if the given sequence of dimension vectors is a valid HN type for the moduli space.\n\nINPUT:\n\nM::QuiverModuli: a moduli space or stack of representations of a quiver.\nhn_type::AbstractVector{<:AbstractVector{Int}}: a sequence of dimension vectors.\n\nOUTPUT:\n\nwhether the given sequence is a valid Harder-Narasimhan type for M.\n\nEXAMPLES:\n\nSome HN types for the 3-Kronecker quiver with dimension vector [2, 3]:\n\njulia> Q = mKronecker_quiver(3); M = QuiverModuliSpace(Q, [2, 3]);\n\njulia> is_HN_type(M, [[2, 3]])\ntrue\n\njulia> is_HN_type(M, [[1, 1], [1, 2]])\ntrue\n\njulia> is_HN_type(M, [[1, 2], [1, 1]])\nfalse\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.is_Luna_type-Tuple{QuiverModuli, Any}","page":"All methods","title":"QuiverTools.is_Luna_type","text":"is_Luna_type(M::QuiverModuli, tau)\n\nChecks if the given tau is a valid Luna type for M.\n\nINPUT:\n\nM::QuiverModuli: a moduli space or stack of representations of a quiver.\ntau::Dict{AbstractVector{Int}, Vector{Int}}: a Luna type for M.\n\nOUTPUT:\n\nwhether the given tau is a valid Luna type for M.\n\nEXAMPLES:\n\nNontrivial Luna types for the 3-Kronecker quiver:\n\njulia> Q = mKronecker_quiver(3); M = QuiverModuliSpace(Q, [3, 3]);\n\njulia> l = Dict([1, 1] => [1], [2, 2] => [1]);\n\njulia> is_Luna_type(M, l)\ntrue\n\nThe zero dimensional case:\n\njulia> Q = mKronecker_quiver(3); X = QuiverModuliSpace(Q, [0, 0]);\n\njulia> is_Luna_type(X, Dict([0, 0] => [1]))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.is_Schur_root-Tuple{Quiver, AbstractVector{Int64}}","page":"All methods","title":"QuiverTools.is_Schur_root","text":"Checks if d is a Schur root for Q.\n\nBy Lemma 4.2, arXiv:0802.2147, this is equivalent to the existence of a stable representation of dimension vector d for the canonical stability parameter.\n\nEXAMPLES:\n\njulia> Q = mKronecker_quiver(3); d = [2,3];\n\njulia> is_Schur_root(Q, d)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.is_acyclic-Tuple{Quiver}","page":"All methods","title":"QuiverTools.is_acyclic","text":"Checks wether the quiver is acyclic, i.e. has no oriented cycles.\n\njulia> Q = mKronecker_quiver(4);\n\njulia> is_acyclic(Q)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.is_amply_stable","page":"All methods","title":"QuiverTools.is_amply_stable","text":"Checks wether the dimension vector d is amply stable with respect to the slope function theta/denominator.\n\nThis means that the codimension of the unstable locus in the parameter space is at least 2.\n\nEXAMPLES:\n\njulia> Q = mKronecker_quiver(3); d = [2, 3];\n\njulia> is_amply_stable(Q, d, [3, -2])\ntrue\n\njulia> is_amply_stable(Q, d, [-3, 2])\nfalse\n\njulia> is_amply_stable(Q, [3, 0], [0, -3])\ntrue\n\n\n\n\n\n","category":"function"},{"location":"methods/#QuiverTools.is_amply_stable-Tuple{QuiverModuli}","page":"All methods","title":"QuiverTools.is_amply_stable","text":"is_amply_stable(M::QuiverModuli)\n\nChecks wether the dimension vector d is amply stable with respect to the slope function theta/denominator.\n\nThis means that the codimension of the unstable locus in the parameter space is at least 2.\n\nINPUT:\n\nM::QuiverModuli: a moduli space or stack of representations of a quiver.\n\nOUTPUT:\n\nwhether the codimension of the unstable locus is at least 2.\n\nEXAMPLES:\n\njulia> Q = mKronecker_quiver(3); M = QuiverModuliSpace(Q, [2, 3]);\n\njulia> is_amply_stable(M)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.is_connected-Tuple{Quiver}","page":"All methods","title":"QuiverTools.is_connected","text":"Checks wether the underlying graph of the quiver is connected.\n\nEXAMPLES:\n\njulia> Q = Quiver([0 1 0; 0 0 1; 1 0 0]);\n\njulia> is_connected(Q)\ntrue\n\njulia> Q = Quiver([0 1 0; 1 0 0; 0 0 2]);\n\njulia> is_connected(Q)\nfalse\n\njulia> # The 4-Kronecker quiver:\n\njulia> Q = mKronecker_quiver(4);\n\njulia> is_connected(Q)\ntrue\n\njulia> # The 4-loop quiver:\n\njulia> Q = loop_quiver(4);\n\njulia> is_connected(Q)\ntrue\n\njulia> # The 4-subspace quiver:\n\njulia> Q = subspace_quiver(4);\n\njulia> is_connected(Q)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.is_coprime-Tuple{AbstractVector{Int64}, AbstractVector{Int64}}","page":"All methods","title":"QuiverTools.is_coprime","text":"Checks wether the given dimension vector d is theta-coprime for the stability parameter theta.\n\nEXAMPLES:\n\njulia> d = [2, 3]; theta = [3, -2];\n\njulia> is_coprime(d, theta)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.is_coprime-Tuple{AbstractVector{Int64}}","page":"All methods","title":"QuiverTools.is_coprime","text":"Checks if the gcd of all the entries of d is 1.\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.is_coprime-Tuple{QuiverModuli}","page":"All methods","title":"QuiverTools.is_coprime","text":"is_coprime(M::QuiverModuli)\n\nChecks if the stability parameter is coprime with the dimension vector, i.e., if for all subdimension vectors e of d, thetacdot e neq 0.\n\nINPUT:\n\nM::QuiverModuli: a moduli space or stack of representations of a quiver.\n\nOUTPUT:\n\nwhether the dimension vector M.d is theta-coprime for M.theta.\n\nEXAMPLES:\n\njulia> Q = mKronecker_quiver(3);\n\njulia> M = QuiverModuliSpace(Q, [2, 3]);\n\njulia> is_coprime(M)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.is_generic_subdimension_vector-Tuple{Quiver, AbstractVector{Int64}, AbstractVector{Int64}}","page":"All methods","title":"QuiverTools.is_generic_subdimension_vector","text":"Checks if e is a generic subdimension vector of d.\n\nA dimension vector e is called a generic subdimension vector of d if a generic representation of dimension vector d possesses a subrepresentation of dimension vector e.\n\nBy Theorem 5.3, arXiv:0802.2147, e is a generic subdimension vector of d if and only if\n\ned-e geq 0\n\nfor all generic subdimension vectors e of e.\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.is_nonempty-Tuple{QuiverModuli}","page":"All methods","title":"QuiverTools.is_nonempty","text":"is_nonempty(M::QuiverModuli)\n\nChecks if the quiver moduli is nonempty.\n\nINPUT:\n\nM::QuiverModuli: a moduli space or stack of representations of a quiver.\n\nOUTPUT:\n\nwhether the moduli space is nonempty.\n\nEXAMPLES:\n\njulia> Q = mKronecker_quiver(3);\n\njulia> M = QuiverModuliSpace(Q, [2, 3]);\n\njulia> is_nonempty(M)\ntrue\n\njulia> M = QuiverModuliSpace(Q, [2, 3], [-3, 2]);\n\njulia> is_nonempty(M)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.is_projective-Tuple{QuiverModuli}","page":"All methods","title":"QuiverTools.is_projective","text":"is_projective(M::QuiverModuli)\n\nChecks if the moduli space is projective.\n\nINPUT:\n\nM: a moduli space of representations of a quiver.\n\nOUTPUT:\n\nwhether the moduli space is projective.\n\nEXAMPLES:\n\nThe moduli space of the 3-Kronecker quiver is projective:\n\njulia> Q = mKronecker_quiver(3); M = QuiverModuliSpace(Q, [2, 3]);\n\njulia> is_projective(M)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.is_sink-Tuple{Quiver, Int64}","page":"All methods","title":"QuiverTools.is_sink","text":"Checks if the vertex j is a sink, i.e., a vertex with no outgoing arrows.\n\nEXAMPLES:\n\njulia> Q = mKronecker_quiver(4);\n\njulia> is_sink(Q, 1)\nfalse\n\njulia> is_sink(Q, 2)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.is_smooth-Tuple{QuiverModuliSpace}","page":"All methods","title":"QuiverTools.is_smooth","text":"is_smooth(M::QuiverModuliSpace)\n\nChecks if the moduli space is smooth.\n\nINPUT:\n\nM: a moduli space of representations of a quiver.\n\nOUTPUT:\n\nwhether the moduli space is smooth.\n\nEXAMPLES:\n\nSetups with d theta-coprime are smooth:\n\njulia> Q = mKronecker_quiver(3); M = QuiverModuliSpace(Q, [2, 3]);\n\njulia> is_smooth(M)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.is_smooth-Tuple{QuiverModuliStack}","page":"All methods","title":"QuiverTools.is_smooth","text":"is_smooth(M::QuiverModuliStack)\n\nChecks if the moduli stack is smooth.\n\nThis is always trus, as the quotient stack of a smooth variety is smooth.\n\nINPUT:\n\nM: a moduli stack of representations of a quiver.\n\nOUTPUT:\n\ntrue\n\nEXAMPLES:\n\njulia> Q = mKronecker_quiver(3); M = QuiverModuliStack(Q, [2, 3]);\n\njulia> is_smooth(M)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.is_source-Tuple{Quiver, Int64}","page":"All methods","title":"QuiverTools.is_source","text":"Checks if the vertex i is a source, i.e., a vertex with no incoming arrows.\n\nEXAMPLES:\n\njulia> Q = mKronecker_quiver(4);\n\njulia> is_source(Q, 1)\ntrue\n\njulia> is_source(Q, 2)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.is_subdimension_vector-Tuple{AbstractVector{Int64}, AbstractVector{Int64}}","page":"All methods","title":"QuiverTools.is_subdimension_vector","text":"is_subdimension_vector(e::AbstractVector{Int}, d::AbstractVector{Int})\n\nCheck if vector e is a subdimension of vector d.\n\nINPUT:\n\ne: An abstract vector of integers.\nd: An abstract vector of integers.\n\nOUTPUT: whether e is a subdimension of d.\n\nEXAMPLE:\n\njulia> QuiverTools.is_subdimension_vector([1, 1], [2, 3])\ntrue\n\njulia> QuiverTools.is_subdimension_vector([1, 1], [1, 1])\ntrue\n\njulia> QuiverTools.is_subdimension_vector([1, 2], [1, 1])\nfalse\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.local_quiver_setting-Tuple{QuiverModuli, Any}","page":"All methods","title":"QuiverTools.local_quiver_setting","text":"local_quiver_setting(M::QuiverModuli, tau)\n\nReturns the local quiver and dimension vector for the given Luna type.\n\nINPUT:\n\nM::QuiverModuli: a moduli space or stack of representations of a quiver.\ntau::Dict{AbstractVector{Int}, Vector{Int}}: a Luna type for M.\n\nOUTPUT:\n\na dictionary with the local quiver Q and dimension vector d for the given Luna type.\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.loop_quiver-Tuple{Int64}","page":"All methods","title":"QuiverTools.loop_quiver","text":"loop_quiver(m::Int)\n\nConstructs a loop quiver with m vertices.\n\nINPUT:\n\nm: The number of vertices in the loop quiver.\n\nOUTPUT: A loop quiver with m vertices.\n\nEXAMPLES:\n\njulia> loop_quiver(4)\n4-loop quiver, with adjacency matrix [4;;]\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.mKronecker_quiver","page":"All methods","title":"QuiverTools.mKronecker_quiver","text":"mKronecker_quiver(m::Int)\n\nConstructs a Kronecker quiver with m vertices.\n\nINPUT:\n\nm: (Default = 2) The number of arrows in the Kronecker quiver.\n\nOUTPUT: A Kronecker quiver with m vertices.\n\nEXAMPLES:\n\njulia> mKronecker_quiver(3)\n3-Kronecker quiver, with adjacency matrix [0 3; 0 0]\n\n\n\n\n\n","category":"function"},{"location":"methods/#QuiverTools.motive","page":"All methods","title":"QuiverTools.motive","text":"motive(Q, d, theta, denom)\n\nReturns the motive of the moduli stack of theta-semistable representations.\n\nINPUT:\n\nQ: a quiver.\nd: a dimension vector.\ntheta: a stability parameter. Default is the canonical stability.\ndenom: a function. Default is the sum.\n\nOUTPUT:\n\nThe motive as an element in the function field \\mathbb{Q}(L).\n\nEXAMPLES:\n\njulia> Q = mKronecker_quiver(3);\n\njulia> motive(Q, [2, 3])\n(-L^6 - L^5 - 3*L^4 - 3*L^3 - 3*L^2 - L - 1)//(L - 1)\n\n\n\n\n\n","category":"function"},{"location":"methods/#QuiverTools.narrows-Tuple{Quiver}","page":"All methods","title":"QuiverTools.narrows","text":"Returns the number of arrows of the quiver.\n\njulia> Q = mKronecker_quiver(4);\n\njulia> narrows(Q) == 4\ntrue\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.nvertices-Tuple{Quiver}","page":"All methods","title":"QuiverTools.nvertices","text":"Returns the number of vertices of the quiver.\n\njulia> Q = mKronecker_quiver(4);\n\njulia> nvertices(Q) == 2\ntrue\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.opposite_quiver-Tuple{Quiver}","page":"All methods","title":"QuiverTools.opposite_quiver","text":"\" Returns a Quiver with the same vertices and an arrow j to i for every arrow  i to j in the original quiver.\n\nINPUT:\n\nQ::Quiver: The quiver to be reversed.\n\nOUTPUT: A quiver with the same vertices and reversed arrows.\n\nEXAMPLES:\n\njulia> Q = mKronecker_quiver()\n2-Kronecker quiver, with adjacency matrix [0 2; 0 0]\n\njulia> opposite_quiver(Q)\nopposite of 2-Kronecker quiver, with adjacency matrix [0 0; 2 0]\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.outdegree-Tuple{Quiver, Int64}","page":"All methods","title":"QuiverTools.outdegree","text":"Returns the number of outgoing arrows from the vertex i.\n\nEXAMPLES:\n\njulia> Q = mKronecker_quiver(4);\n\njulia> outdegree(Q, 1)\n4\n\njulia> outdegree(Q, 2)\n0\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.point_class","page":"All methods","title":"QuiverTools.point_class","text":"point_class(M::QuiverModuliSpace)\n\nReturns the point class of the moduli space M.\n\nINPUT:\n\nM: a moduli space of representations of a quiver.\nchi: a choice of linearization to construct the universal bundles.\n\nOUTPUT:\n\nthe point class of the moduli space, as a polynomial in its Chow ring.\n\nEXAMPLES:\n\nA projective 7-fold:\n\njulia> Q = mKronecker_quiver(8);\n\njulia> M = QuiverModuliSpace(Q, [1, 1]);\n\njulia> point_class(M, [1, 0])\nx21^7\n\nOur favourite 6-fold:\n\njulia> Q = mKronecker_quiver(3);\n\njulia> M = QuiverModuliSpace(Q, [2, 3]);\n\njulia> point_class(M)\nx23^2\n\n\n\n\n\n","category":"function"},{"location":"methods/#QuiverTools.pullback_from_quotient-Tuple{Any, Any}","page":"All methods","title":"QuiverTools.pullback_from_quotient","text":"Takes a ring R and a polynomial in R/I and returns the canonical preimage of f in R.\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.semisimple_moduli_space-Tuple{QuiverModuliSpace}","page":"All methods","title":"QuiverTools.semisimple_moduli_space","text":"semisimple_moduli_space(M::QuiverModuli)\n\nReturns the moduli space with the zero stability parameter.\n\nAny quiver moduli space is (quasi)projective-over-affine; this is the affine base.\n\nINPUT:\n\nM: a moduli space of representations of a quiver.\n\nOUTPUT:\n\nthe moduli space with the zero stability parameter.\n\nEXAMPLES:\n\njulia> Q = mKronecker_quiver(3); M = QuiverModuliSpace(Q, [2, 3]);\n\njulia> dimension(semisimple_moduli_space(M))\n0\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.semistable_equals_stable-Tuple{QuiverModuli}","page":"All methods","title":"QuiverTools.semistable_equals_stable","text":"semistable_equals_stable(M::QuiverModuli)\n\nChecks if stability and semistability are equivalent on the given moduli space. In other words, checks if there are no properly semistable points in the representation space.\n\nINPUT:\n\nM::QuiverModuli: a moduli space or stack of representations of a quiver.\n\nOUTPUT:\n\nwhether every semistable representation is stable.\n\nEXAMPLES:\n\nIf the dimension vector is coprime with the stability parameter, then semistability and stability are equivalent:\n\njulia> Q = mKronecker_quiver(3); M = QuiverModuliSpace(Q, [2, 3]);\n\njulia> semistable_equals_stable(M)\ntrue\n\nHowever, this is not necessarily the case:\n\njulia> Q = mKronecker_quiver(3); M = QuiverModuliSpace(Q, [3, 3]);\n\njulia> semistable_equals_stable(M)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.slope","page":"All methods","title":"QuiverTools.slope","text":"Returns the slope of the dimension vector d with respect to the stability parameter theta and a choice of a denominator function.\n\nEXAMPLE:\n\njulia> slope([2,3], [3,-2])\n0//1\n\n\n\n\n\n","category":"function"},{"location":"methods/#QuiverTools.solve-Tuple{Any, Any}","page":"All methods","title":"QuiverTools.solve","text":"solve(A, b)\n\nSolve Acdot x = b for A upper triangular via back substitution.\n\nThis is an internal method only used in the implementation of the Hodge polynomial and to compute motives.\n\nINPUT:\n\nA::AbstractMatrix: an upper triangular matrix.\nb::AbstractVector: a vector.\n\nOUTPUT:\n\nthe solution x to the equation.\n\nEXAMPLES:\n\njulia> A = [1 2 3; 0 4 5; 0 0 6];\n\njulia> b = [1, 2, 3];\n\njulia> QuiverTools.solve(A, b)\n3-element Vector{Any}:\n -0.25\n -0.125\n  0.5\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.subspace_quiver-Tuple{Int64}","page":"All methods","title":"QuiverTools.subspace_quiver","text":"subspace_quiver(m::Int)\n\nConstructs a subspace quiver with m vertices.\n\nINPUT:\n\nm: The number of subspace-vertices.\n\nOUTPUT: A subspace quiver with m subspaces.\n\nEXAMPLES:\n\njulia> subspace_quiver(3)\n3-subspace quiver, with adjacency matrix [0 0 0 1; 0 0 0 1; 0 0 0 1; 0 0 0 0]\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.symmetric_polynomial-Tuple{Any, Int64}","page":"All methods","title":"QuiverTools.symmetric_polynomial","text":"symmetric_polynomial(vars, degree)\n\nReturns the symmetric polynomial of degree degree in the variables vars.\n\nINPUT:\n\nvars: a list of variables.\ndegree: the degree of the wanted symmetric polynomial.\n\nOUTPUT:\n\nThe symmetric polynomial of degree degree in the variables vars.\n\nEXAMPLES:\n\njulia> using Singular;\n\njulia> R, vars = polynomial_ring(Singular.QQ, [\"x\", \"y\", \"z\"]);\n\njulia> QuiverTools.symmetric_polynomial(vars, 2)\nx*y + x*z + y*z\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.thin_dimension_vector-Tuple{Quiver}","page":"All methods","title":"QuiverTools.thin_dimension_vector","text":"thin_dimension_vector(Q::Quiver)\n\nCompute the thin dimension vector for a given quiver Q.\n\nINPUT:\n\nQ::Quiver: The input quiver.\n\nOUTPUT:\n\nA vector of ones of length n.\n\nEXAMPLE:\n\nThere is not much to it:\n\njulia> Q = mKronecker_quiver(3);\n\njulia> QuiverTools.thin_dimension_vector(Q) == [1, 1]\ntrue\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.three_vertex_quiver-Tuple{Int64, Int64, Int64}","page":"All methods","title":"QuiverTools.three_vertex_quiver","text":"three_vertex_quiver(m12::Int, m13::Int, m23::Int)\n\nConstructs a three-vertex quiver with the given edge weights.\n\nINPUT:\n\nm12: The number of arrows from vertex 1 to vertex 2.\nm13: The number of arrows from vertex 1 to vertex 3.\nm23: The number of arrows from vertex 2 to vertex 3.\n\nOUTPUT: A three-vertex quiver with the specified arrows.\n\nEXAMPLES:\n\njulia> three_vertex_quiver(1, 2, 3)\nAcyclic 3-vertex quiver, with adjacency matrix [0 1 2; 0 0 3; 0 0 0]\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.total_Chern_class_universal","page":"All methods","title":"QuiverTools.total_Chern_class_universal","text":"total_Chern_class_universal(M::QuiverModuliSpace, i, chi)\n\nReturns the total Chern class of the universal bundle U_i(chi).\n\nINPUT:\n\nM: a moduli space of representations of a quiver.\ni: the universal bundle we want the Chern class of.\nchi: a choice of linearization to construct U_i(chi).\n\nOUTPUT:\n\nthe total Chern class of the universal bundle U_i(chi).\n\nEXAMPLES:\n\nThe universal Chern classes on both vertices of our favourite 3-Kronecker quiver:\n\njulia> Q  = mKronecker_quiver(3); M = QuiverModuliSpace(Q, [2, 3]);\n\njulia> total_Chern_class_universal(M, 1)\nx11 + x12 + 1\n\njulia> total_Chern_class_universal(M, 2)\nx21 + x22 + x23 + 1\n\n\n\n\n\n","category":"function"},{"location":"methods/#QuiverTools.underlying_graph-Tuple{Quiver}","page":"All methods","title":"QuiverTools.underlying_graph","text":"Returns the (necessarily symmetric) adjacency matrix of the underlying graph of the quiver.\n\njulia> Q = mKronecker_quiver(4);\n\njulia> QuiverTools.underlying_graph(Q) == [0 4; 4 0]\ntrue\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.unit_vector-Tuple{Int64, Int64}","page":"All methods","title":"QuiverTools.unit_vector","text":"unit_vector(n::Int, i::Int)\n\nReturn a vector of length n with a 1 at index i and 0 elsewhere.\n\nINPUT:\n\nn::Int: The length of the unit vector.\ni::Int: The index at which to place the 1 in the unit vector.\n\nOUTPUT: A unit vector of length n with a 1 at index i and 0 elsewhere.\n\nEXAMPLES:\n\njulia> QuiverTools.unit_vector(3, 2) == [0, 1, 0]\ntrue\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.unit_vector-Tuple{Quiver, Int64}","page":"All methods","title":"QuiverTools.unit_vector","text":"unit_vector(Q::Quiver, i::Int)\n\nReturn a dimension vector for the quiver Q with a 1 at index i and 0 elsewhere.\n\nINPUT:\n\nQ::Quiver: The input quiver.\ni::Int: The index at which to place the 1 in the unit vector.\n\nOUTPUT:\n\nA dimension vector for the quiver Q with a 1 at index i and 0 elsewhere.\n\nEXAMPLES:\n\njulia> Q = mKronecker_quiver(3);\n\njulia> QuiverTools.unit_vector(Q, 2) == [0, 1]\ntrue\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.weight_irreducible_component_canonical_on_stratum","page":"All methods","title":"QuiverTools.weight_irreducible_component_canonical_on_stratum","text":"Computes the weight of the irreducible component of omega_R_Z on a Harder-Narasimhan stratum for the 1-PS corresponding to each HN type. More explicitly, if omega_X = mathcalO(rH), this returns the weight of the pullback of O(H) on the given stratum.\n\n\n\n\n\n","category":"function"},{"location":"methods/#QuiverTools.weights_endomorphism_universal_bundle_on_stratum","page":"All methods","title":"QuiverTools.weights_endomorphism_universal_bundle_on_stratum","text":"Computes the weights of the endomorphism of the universal bundle U_i otimes U_j on the given Harder-Narasimhan stratum for the 1-PS relative to the HN type.\n\n\n\n\n\n","category":"function"},{"location":"methods/#QuiverTools.weights_universal_bundle_onstratum","page":"All methods","title":"QuiverTools.weights_universal_bundle_onstratum","text":"Returns the weights of a universal bundle U_i(a) for the linearization a for the 1-PS corresponding to the given HN type.\n\n\n\n\n\n","category":"function"},{"location":"methods/#QuiverTools.zero_vector-Tuple{Int64}","page":"All methods","title":"QuiverTools.zero_vector","text":"zero_vector(n::Int)\n\nCreate a zero vector of length n.\n\nINPUT:\n\nn::Int: The length of the zero vector.\n\nOUTPUT:\n\nA zero vector of length n.\n\nEXAMPLE:\n\nThere is not much to it:\n\njulia> QuiverTools.zero_vector(3) == [0, 0, 0]\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#QuiverTools","page":"QuiverTools","title":"QuiverTools","text":"","category":"section"},{"location":"#Introduction","page":"QuiverTools","title":"Introduction","text":"","category":"section"},{"location":"","page":"QuiverTools","title":"QuiverTools","text":"QuiverTools is a software suite for treatment of quiver representations, their roots, their moduli spaces and computations of several invariants of these.","category":"page"},{"location":"","page":"QuiverTools","title":"QuiverTools","text":"QuiverTools is available as a Julia package and as a Sage library.","category":"page"},{"location":"#Installation","page":"QuiverTools","title":"Installation","text":"","category":"section"},{"location":"","page":"QuiverTools","title":"QuiverTools","text":"At the moment the package is not registered, so you can install it by running the following command in the Julia REPL:","category":"page"},{"location":"","page":"QuiverTools","title":"QuiverTools","text":"julia> using Pkg\n\njulia> Pkg.add(url=\"https://github.com/QuiverTools/QuiverTools.jl.git\")","category":"page"},{"location":"#Acknowledgements","page":"QuiverTools","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"QuiverTools","title":"QuiverTools","text":"QuiverTools is developed by P. Belmans, H. Franzen and G. Petrella.","category":"page"},{"location":"","page":"QuiverTools","title":"QuiverTools","text":"The Julia version is developed and maintained by G. Petrella.","category":"page"},{"location":"","page":"QuiverTools","title":"QuiverTools","text":"G. Petrella was supported by the Luxembourg National Research Fund (FNR–17953441).","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/#Installation","page":"Tutorial","title":"Installation","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"At the moment the package is not registered, so you can install it by running the following command in the Julia REPL:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> using Pkg\n\njulia> Pkg.add(url=\"https://github.com/QuiverTools/QuiverTools.jl.git\")","category":"page"},{"location":"tutorial/#Basic-functionalities","page":"Tutorial","title":"Basic functionalities","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To start using QuiverTools in the REPL, one first must import it.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> using QuiverTools","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Quivers can be built by passing the adjacency matrix to the Quiver() constructor:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> Quiver([0 3; 0 0])\nQuiver with adjacency matrix [0 3; 0 0]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The constructor accepts an optional string for naming the quiver:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> MyQ = Quiver([0 3; 0 0], \"My personal quiver\")\nMy personal quiver, with adjacency matrix [0 3; 0 0]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"QuiverTools has several constructors in place for many common examples:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> mKronecker_quiver(4)\n4-Kronecker quiver, with adjacency matrix [0 4; 0 0]\n\njulia> loop_quiver(5)\n5-loop quiver, with adjacency matrix [5;;]\n\njulia> subspace_quiver(3)\n3-subspace quiver, with adjacency matrix [0 0 0 1; 0 0 0 1; 0 0 0 1; 0 0 0 0]\n\njulia> three_vertex_quiver(1, 6, 7)\nAn acyclic 3-vertex quiver, with adjacency matrix [0 1 6; 0 0 7; 0 0 0]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Lastly, there is a handy constructor using strings:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> Q = Quiver(\"1--2,1---3,2-4,2--3\")\nQuiver with adjacency matrix [0 2 3 0; 0 0 2 1; 0 0 0 0; 0 0 0 0]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Dimension vectors and stability parameters are represented by AbstractVector{Int} objects, while under the hood these are encoded using the StaticArrays package.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> Q = mKronecker_quiver(3); d = [2,3];\n\njulia> θ = canonical_stability(Q, d)\n2-element Vector{Int64}:\n  9\n -6\n\njulia> is_coprime(d, θ)\ntrue","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Here, is_coprime() checks if d is θ-coprime, i.e., if none of the proper subdimension vectors 0 neq d nleq d satisfies theta cdot d = 0.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The bilinear Euler form relative to a quiver Q of any two vectors in mathbbZ^Q_0 can be computed:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> Q = mKronecker_quiver(3); d = [2,2]; e = [3,4];\n\njulia> Euler_form(Q, d, e)\n-10\n\njulia> Euler_form(Q, e, d)\n-4","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This allows to verify whether any given dimension vector belongs to the fundamental domain of the problem.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The fundamental domain is the cone of dimension vectors in mathbbZ^Q_0 such that the symmetric Tits form is negative on all the simple roots, i.e., for all vertices i,","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(s_i d) = langle d s_irangle + langle s_i drangle  leq 0","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"where s_i is the dimension vector with all entries set to 0 and the i-th set to 1.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> QuiverTools.in_fundamental_domain(Q, d)\ntrue\n\njulia> QuiverTools.in_fundamental_domain(Q, [1,3])\nfalse","category":"page"},{"location":"tutorial/#Stable-and-semistable-dimension-vectors","page":"Tutorial","title":"Stable and semistable dimension vectors","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"One can check if semistable, respectively stable representations exist for a given dimension vector and stability parameter:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> Q = mKronecker_quiver(3); d = [2,3]; θ = [3,-2];\n\njulia> has_semistables(Q, d, θ)\ntrue\n\njulia> has_stables(Q, d, θ)\ntrue\n\njulia> K2 = mKronecker_quiver(2);\n\njulia> has_stables(K2, [2,2], [1,-1])\nfalse\n\njulia> has_semistables(K2, [2,2], [1,-1])\ntrue","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"One can also determine whether stable representations exist at all for a given dimension vector by checking if it is a Schur root:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> Q = mKronecker_quiver(3); d = [2, 2];\n\njulia> QuiverTools.is_Schur_root(Q, d)\ntrue\n\njulia> K2 = mKronecker_quiver(2);\n\njulia> QuiverTools.is_Schur_root(K2, d)\nfalse","category":"page"},{"location":"tutorial/#Quiver-Moduli","page":"Tutorial","title":"Quiver Moduli","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"QuiverTools implements the abstract QuiverModuli type and the two concrete types QuiverModuliSpace and QuiverModuliStack.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> Q = mKronecker_quiver(3);\n\njulia> M = QuiverModuliSpace(Q, [2, 3])\nModuli space of semistable representations of 3-Kronecker quiver, with adjacency matrix [0 3; 0 0]\n      with dimension vector [2, 3] and stability parameter [9, -6]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"All the functionalities of QuiverTools are accessible either directly, by passing a quiver, dimension vector, stability parameter etc, or directly via these objects. See the docstring of each method for more information and examples.","category":"page"},{"location":"tutorial/#Harder-Narasimhan-types","page":"Tutorial","title":"Harder-Narasimhan types","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This module provides methods to investigate the Harder-Narasimhan stratification of the parameter space mathrmR(Qmathbfd).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> Q = mKronecker_quiver(3); M = QuiverModuliStack(Q, [2, 3], [3, -2]);\n\njulia> allHNtypes(M)\n8-element Vector{Vector{Vector{Int64}}}:\n [[2, 3]]\n [[1, 1], [1, 2]]\n [[2, 2], [0, 1]]\n [[2, 1], [0, 2]]\n [[1, 0], [1, 3]]\n [[1, 0], [1, 2], [0, 1]]\n [[1, 0], [1, 1], [0, 2]]\n [[2, 0], [0, 3]]\n\njulia> is_amply_stable(M)\ntrue","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The method is_amply_stable() determines whether the codimension of the θ-semistable locus, mathrmR^theta-sst(Qmathbfd)subsetmathrmR(Qmathbfd), is at least 2.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The method all_HN_types() provides a list of all the Harder-Narasimhan types that appear in the problem.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The method all_Teleman_bounds() computes the bounds to apply Teleman quantization on the non-dense strata. The output is a dictionary whose keys are the HN types and whose values are the weights themselves.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> Q = mKronecker_quiver(3); M = QuiverModuliStack(Q, [2, 3], [3, -2]);\n\njulia> all_Teleman_bounds(M)\nDict{Vector{Vector{Int64}}, Int64} with 7 entries:\n  [[2, 2], [0, 1]]         => 20\n  [[2, 1], [0, 2]]         => 100\n  [[1, 0], [1, 2], [0, 1]] => 100\n  [[1, 0], [1, 3]]         => 120\n  [[1, 0], [1, 1], [0, 2]] => 90\n  [[1, 1], [1, 2]]         => 15\n  [[2, 0], [0, 3]]         => 90","category":"page"},{"location":"tutorial/#Verify-Teleman-inequalities","page":"Tutorial","title":"Verify Teleman inequalities","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In the following example, for each ij and on each Harder-Narasimhan stratum, we compute the weight of mathcalU_i^vee otimes mathcalU_j relative to the 1-PS corresponding to the HN stratum. These are then compared to the Teleman bounds.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> Q = mKronecker_quiver(3); M = QuiverModuliStack(Q, [2, 3]);\n\njulia> hn = all_Teleman_bounds(M)\nDict{Vector{Vector{Int64}}, Int64} with 7 entries:\n  [[2, 2], [0, 1]]         => 20\n  [[2, 1], [0, 2]]         => 100\n  [[1, 0], [1, 2], [0, 1]] => 100\n  [[1, 0], [1, 3]]         => 120\n  [[1, 0], [1, 1], [0, 2]] => 90\n  [[1, 1], [1, 2]]         => 15\n  [[2, 0], [0, 3]]         => 90\n\njulia> endom = all_weights_endomorphisms_universal_bundle(M)\nDict{Vector{Vector{Int64}}, Vector{Int64}} with 7 entries:\n  [[2, 2], [0, 1]]         => [0, 5, -5, 0]\n  [[2, 1], [0, 2]]         => [0, 10, -10, 0]\n  [[1, 0], [1, 2], [0, 1]] => [0, 10, 15, -10, 0, 5, -15, -5, 0]\n  [[1, 0], [1, 3]]         => [0, 15, -15, 0]\n  [[1, 0], [1, 1], [0, 2]] => [0, 5, 10, -5, 0, 5, -10, -5, 0]\n  [[1, 1], [1, 2]]         => [0, 5, -5, 0]\n  [[2, 0], [0, 3]]         => [0, 5, -5, 0]\n\njulia> all(maximum(endom[key]) < hn[key] for key in keys(hn))\ntrue\n\njulia> does_Teleman_inequality_hold(M)\ntrue","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The fact that all of these inequalities are satisfied allows to conclude that the higher cohomology of mathcalU_i^vee otimes mathcalU_j vanishes.","category":"page"},{"location":"tutorial/#Canonical-decompositions-and-roots","page":"Tutorial","title":"Canonical decompositions and roots","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"QuiverTools provides a method to compute the canonical decomposition of a dimension vector.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Given a dimension vector d, the canonical decomposition is a list of Schur roots beta_i such that d = sum_i beta_i and mathrmext(beta_ibeta_j) = 0 for all i j.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"It is a theorem of Schofield that the canonical decomposition exists and is described by the condition above. If this is the canonical decomposition of d, then the general representation of dimension vector d is a direct sum of indecomposable representations of dimension vector beta_i.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> canonical_decomposition(Q, d)\n1-element Vector{Vector{Int64}}:\n [2, 3]\n\njulia> canonical_decomposition(Q, [12, 3])\n6-element Vector{Vector{Int64}}:\n [1, 0]\n [1, 0]\n [1, 0]\n [3, 1]\n [3, 1]\n [3, 1]\n\njulia> canonical_decomposition(Q, [12, 4])\n4-element Vector{Vector{Int64}}:\n [3, 1]\n [3, 1]\n [3, 1]\n [3, 1]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"QuiverTools also implements computations of generic hom and ext for dimension vectors.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> e = [1, 2];\n\njulia> generic_hom(Q, d, e)\n0\n\njulia> generic_hom(Q, e, d)\n0\n\njulia> generic_ext(Q, d, e)\n4\n\njulia> generic_ext(Q, e, d)\n1","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This allows to determine whether a root is real, imaginary isotropic or imaginary anisotropic.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> ds = QuiverTools.all_subdimension_vectors([5, 5])\n6×6 Matrix{Vector{Int64}}:\n [0, 0]  [0, 1]  [0, 2]  [0, 3]  [0, 4]  [0, 5]\n [1, 0]  [1, 1]  [1, 2]  [1, 3]  [1, 4]  [1, 5]\n [2, 0]  [2, 1]  [2, 2]  [2, 3]  [2, 4]  [2, 5]\n [3, 0]  [3, 1]  [3, 2]  [3, 3]  [3, 4]  [3, 5]\n [4, 0]  [4, 1]  [4, 2]  [4, 3]  [4, 4]  [4, 5]\n [5, 0]  [5, 1]  [5, 2]  [5, 3]  [5, 4]  [5, 5]\n\njulia> filter(d -> QuiverTools.is_real_root(Q, d), ds)\n4-element Vector{Vector{Int64}}:\n [1, 0]\n [0, 1]\n [3, 1]\n [1, 3]\n\njulia> filter(d -> QuiverTools.is_isotropic_root(Q, d), ds)\n1-element Vector{Vector{Int64}}:\n [0, 0]\n\njulia> filter(d -> QuiverTools.is_imaginary_root(Q, d), ds)\n20-element Vector{Vector{Int64}}:\n [0, 0]\n [1, 1]\n [2, 1]\n [1, 2]\n [2, 2]\n [3, 2]\n [4, 2]\n [5, 2]\n [2, 3]\n [3, 3]\n [4, 3]\n [5, 3]\n [2, 4]\n [3, 4]\n [4, 4]\n [5, 4]\n [2, 5]\n [3, 5]\n [4, 5]\n [5, 5]","category":"page"},{"location":"tutorial/#Hodge-polynomials","page":"Tutorial","title":"Hodge polynomials","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"QuiverTools features an implementation of the Hodge polynomial of quiver moduli, if the base field is mathbbC and the dimension vector is a coprime Schurian root.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> Q = mKronecker_quiver(3); M = QuiverModuliSpace(Q, [2, 3]);\n\njulia> Hodge_polynomial(M)\nx^6*y^6 + x^5*y^5 + 3*x^4*y^4 + 3*x^3*y^3 + 3*x^2*y^2 + x*y + 1\n\njulia> Hodge_diamond(M)\n7×7 Matrix{Int64}:\n 1  0  0  0  0  0  0\n 0  1  0  0  0  0  0\n 0  0  3  0  0  0  0\n 0  0  0  3  0  0  0\n 0  0  0  0  3  0  0\n 0  0  0  0  0  1  0\n 0  0  0  0  0  0  1","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Note that the i j-th entry of the matrix representing the Hodge diamond is h^ij. In other words, the point of the diamond is on the upper left side of the matrix.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This allows us to conclude that the Picard rank of the moduli space is 1.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> Picard_rank(M)\n1","category":"page"},{"location":"tutorial/#Chow-rings","page":"Tutorial","title":"Chow rings","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"QuiverTools allows to compute the Chow ring for a given quiver moduli space, as well as the point class, the Todd class and the Euler characteristic of a vector bundle, given its Chern character.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> Q = mKronecker_quiver(3); M = QuiverModuliSpace(Q, [2, 3]);\n\njulia> L = Chern_character_line_bundle(M, [3, -2]);\n\njulia> [integral(M, L^i) for i in 0:5]\n6-element Vector{Int64}:\n    1\n   20\n  148\n  664\n 2206\n 5999","category":"page"}]
}
