var documenterSearchIndex = {"docs":
[{"location":"methods/#Methods","page":"All methods","title":"Methods","text":"","category":"section"},{"location":"methods/","page":"All methods","title":"All methods","text":"Here are listed all the available methods of QuiverTools","category":"page"},{"location":"methods/","page":"All methods","title":"All methods","text":"Modules = [QuiverTools]","category":"page"},{"location":"methods/#QuiverTools.Quiver","page":"All methods","title":"QuiverTools.Quiver","text":"A quiver is represented by its adjacency n times n matrix adjacency = (a_ij), where n is the number of vertices and a_ij is the number of arrows i to j.\n\nAttributes:\n\nadjacency is the adjacency matrix of the quiver\nname is the name of the quiver, defaults to \"\".\n\n\n\n\n\n","category":"type"},{"location":"methods/#QuiverTools.CardinalGd-Tuple{Vector{Int64}, Any}","page":"All methods","title":"QuiverTools.CardinalGd","text":"Cardinality of product of general linear groups mathrmGL_d(mathbbF_q).\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.CardinalGl-Tuple{Int64, Any}","page":"All methods","title":"QuiverTools.CardinalGl","text":"Cardinality of general linear group mathrmGL_n(mathbbF_v).\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.CardinalRd-Tuple{Quiver, Vector{Int64}, Any}","page":"All methods","title":"QuiverTools.CardinalRd","text":"Cardinality of representation space mathrmR(Qd), over mathbbF_q.\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.Euler_form-Tuple{Quiver, Vector{Int64}, Vector{Int64}}","page":"All methods","title":"QuiverTools.Euler_form","text":"Computes the Euler form of the quiver for vectors x and y.\n\nThe Euler form is defined as the bilinear form\n\nlangle xyrangle = x^T * E * y\n\nwhere E is the Euler matrix of the quiver.\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.Euler_matrix-Tuple{Quiver}","page":"All methods","title":"QuiverTools.Euler_matrix","text":"Returns the Euler matrix of the quiver.\n\nThe Euler matrix of a quiver Q is defined as \n\nE = I - A\n\nwhere A is the adjacency matrix of Q and I is the identity matrix of the same size as A.\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.Hodge_diamond-Tuple{Quiver, Vector{Int64}, Vector{Int64}}","page":"All methods","title":"QuiverTools.Hodge_diamond","text":"Returns the Hodge diamond of the moduli space of theta-semistable representations of Q with dimension vector d.\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.Hodge_polynomial-Tuple{Quiver, Vector{Int64}, Vector{Int64}}","page":"All methods","title":"QuiverTools.Hodge_polynomial","text":"Returns the Hodge polynomial of the moduli space of theta-semistable representations of Q with dimension vector d.\n\nThe algorithm is based on MR1974891, and the current implementation is translated from the Hodge diamond cutter.\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.Picard_rank-Tuple{Quiver, Vector{Int64}, Vector{Int64}}","page":"All methods","title":"QuiverTools.Picard_rank","text":"Computes the Picard rank of the moduli space of theta-semistable representations of Q with dimension vector d.\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.Teleman_bound_onstratum","page":"All methods","title":"QuiverTools.Teleman_bound_onstratum","text":"Computes the weight on det(N_SR_Z) of the 1-PS lambda corresponding to the given HN type.\n\n\n\n\n\n","category":"function"},{"location":"methods/#QuiverTools.TransferMatrixEntry-NTuple{4, Any}","page":"All methods","title":"QuiverTools.TransferMatrixEntry","text":"Entry of the transfer matrix, as per Corollary 6.9\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.all_HN_types","page":"All methods","title":"QuiverTools.all_HN_types","text":"Returns a list of all the Harder Narasimhan types of representations of Q with dimension vector d, with respect to the slope function theta/slope_denominator.\n\nExamples:\n\njulia> Q = mKronecker_quiver(3); d = [2,3]; theta = [3,-2];\n\njulia> all_HN_types(Q, d, theta)\n8-element Vector{Vector{Vector{Int64}}}:\n [[2, 3]]\n [[1, 1], [1, 2]]\n [[2, 2], [0, 1]]\n [[2, 1], [0, 2]]\n [[1, 0], [1, 3]]\n [[1, 0], [1, 2], [0, 1]]\n [[1, 0], [1, 1], [0, 2]]\n [[2, 0], [0, 3]]\n\njulia> all_HN_types(Q, [3,0], [0,0])\n1-element Vector{Vector{Vector{Int64}}}:\n [[3, 0]]\n\njulia> Q = three_vertex_quiver(1,4,1); d = [4,1,4];\n\njulia> theta = canonical_stability(Q, d);\n\njulia> all_HN_types(Q, d, theta)\n106-element Vector{Vector{Vector{Int64}}}:\n [[4, 1, 4]]\n [[4, 1, 3], [0, 0, 1]]\n [[4, 0, 3], [0, 1, 1]]\n [[4, 0, 3], [0, 1, 0], [0, 0, 1]]\n [[3, 1, 2], [1, 0, 2]]\n [[3, 1, 2], [1, 0, 1], [0, 0, 1]]\n [[3, 0, 2], [1, 1, 2]]\n [[3, 0, 2], [0, 1, 0], [1, 0, 2]]\n [[3, 0, 2], [1, 0, 1], [0, 1, 1]]\n [[3, 0, 2], [1, 1, 1], [0, 0, 1]]\n ⋮\n [[3, 0, 0], [1, 1, 2], [0, 0, 2]]\n [[3, 0, 0], [0, 1, 0], [1, 0, 4]]\n [[3, 0, 0], [0, 1, 0], [1, 0, 3], [0, 0, 1]]\n [[3, 0, 0], [0, 1, 0], [1, 0, 2], [0, 0, 2]]\n [[3, 0, 0], [1, 0, 1], [0, 1, 1], [0, 0, 2]]\n [[3, 0, 0], [1, 1, 1], [0, 0, 3]]\n [[3, 0, 0], [1, 1, 0], [0, 0, 4]]\n [[4, 0, 0], [0, 1, 1], [0, 0, 3]]\n [[4, 0, 0], [0, 1, 0], [0, 0, 4]]\n\n\n\n\n\n","category":"function"},{"location":"methods/#QuiverTools.all_Teleman_bounds","page":"All methods","title":"QuiverTools.all_Teleman_bounds","text":"Computes the weight on det(N_SR_Z) of the 1-PS corresponding to each HN type for the given Q, d, theta and slope_denominator`.\n\n\n\n\n\n","category":"function"},{"location":"methods/#QuiverTools.all_destabilizing_subdimension_vectors","page":"All methods","title":"QuiverTools.all_destabilizing_subdimension_vectors","text":"Returns the subdimension vectors of d with a strictly larger slope than d.\n\n\n\n\n\n","category":"function"},{"location":"methods/#QuiverTools.all_generic_subdimension_vectors-Tuple{Quiver, Vector{Int64}}","page":"All methods","title":"QuiverTools.all_generic_subdimension_vectors","text":"Returns the list of all generic subdimension vectors of d.\n\nExamples:\n\njulia> Q = mKronecker_quiver(3); d = [2,3];\n\njulia> QuiverTools.all_generic_subdimension_vectors(Q, d)\n7-element Vector{Vector{Int64}}:\n [0, 0]\n [0, 1]\n [0, 2]\n [1, 2]\n [0, 3]\n [1, 3]\n [2, 3]\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.all_slope_decreasing_sequences","page":"All methods","title":"QuiverTools.all_slope_decreasing_sequences","text":"Returns the list of all sequences (d^1d^l) which sum to d such that mu(d^1)    mu(d^l)\n\nExamples:\n\njulia> Q = mKronecker_quiver(3); d = [2,3]; theta = [3,-2];\n\njulia> QuiverTools.all_slope_decreasing_sequences(Q, d, theta)\n8-element Vector{Vector{Vector{Int64}}}:\n [[2, 3]]\n [[1, 1], [1, 2]]\n [[2, 2], [0, 1]]\n [[2, 1], [0, 2]]\n [[1, 0], [1, 3]]\n [[1, 0], [1, 2], [0, 1]]\n [[1, 0], [1, 1], [0, 2]]\n [[2, 0], [0, 3]]\n\n\n\n\n\n","category":"function"},{"location":"methods/#QuiverTools.all_weights_endomorphisms_universal_bundle","page":"All methods","title":"QuiverTools.all_weights_endomorphisms_universal_bundle","text":"Computes the weights of the endomorphisms of the universal bundles U_i otimes U_j on all the non-dense Harder-Narasimhan strata for each 1-PS relative to the HN type.\n\n\n\n\n\n","category":"function"},{"location":"methods/#QuiverTools.all_weights_irreducible_component_canonical","page":"All methods","title":"QuiverTools.all_weights_irreducible_component_canonical","text":"Computes the weights of the irreducible component of omega_R_Z on all the non-dense Harder-Narasimhan strata for each 1-PS relative to the HN type. More explicitly, if omega_X = O(rH), this returns the weights of the pullback of mathcalO(H) on each stratum.\n\n\n\n\n\n","category":"function"},{"location":"methods/#QuiverTools.all_weights_universal_bundle","page":"All methods","title":"QuiverTools.all_weights_universal_bundle","text":"Computes the weights of the universal bundle U_i(a) for the linearization a on all the non-dense Harder-Narasimhan strata for each 1-PS corresponding to each HN type.\n\n\n\n\n\n","category":"function"},{"location":"methods/#QuiverTools.canonical_decomposition-Tuple{Quiver, Vector{Int64}}","page":"All methods","title":"QuiverTools.canonical_decomposition","text":"Computes the canonical decomposition of the dimension vector d for the given quiver Q.\n\nIf beta_1 dots beta_ell is a sequence of Schur roots such that, for all i neq j, one has\n\nmathrmext(beta_i beta_j) = mathrmext(beta_j beta_i) = 0\n\nthen the general representation of dimension sum_i beta_i is isomorphic to the direct sum of irreducible representations of dimension vectors beta_i.\n\nSuch a decomposition is called the canonical decomposition.\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.canonical_stability-Tuple{Quiver, Vector{Int64}}","page":"All methods","title":"QuiverTools.canonical_stability","text":"The canonical stability parameter for the couple (Qd) is given by d-  -  - d\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.codimension_HN_stratum-Tuple{Quiver, Vector{Vector{Int64}}}","page":"All methods","title":"QuiverTools.codimension_HN_stratum","text":"Returns the codimension of the given HN stratum.\n\nExamples:\n\njulia> Q = mKronecker_quiver(3); d = [2,3]; theta = [3,-2];\n\njulia> HN = all_HN_types(Q, d, theta)\n8-element Vector{Vector{Vector{Int64}}}:\n [[2, 3]]\n [[1, 1], [1, 2]]\n [[2, 2], [0, 1]]\n [[2, 1], [0, 2]]\n [[1, 0], [1, 3]]\n [[1, 0], [1, 2], [0, 1]]\n [[1, 0], [1, 1], [0, 2]]\n [[2, 0], [0, 3]]\n\njulia> for hntype in HN\n        println(QuiverTools.codimension_HN_stratum(Q, hntype))\n        end\n0\n3\n4\n10\n8\n9\n12\n18\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.double_quiver-Tuple{Quiver}","page":"All methods","title":"QuiverTools.double_quiver","text":"The adjacency matrix of the double of a quiver is the sum of the adjacency matrix of the original quiver and its transpose.\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.extension_matrix-Tuple{Quiver, Vector{Vector{Int64}}}","page":"All methods","title":"QuiverTools.extension_matrix","text":"Given an HN type (d^1d^l) for the quiver Q, returns the upper triangular matrix whose ij-th entry is mathrmext(d^id^j).\n\nThe sum of all the entries is the codimension of the HN stratum; the sum of all the rectangles starting on the \"up-diagonal\" (where the 1s go in a Jordan form) and going all the way to the entry 1ell is at least 1.\n\nThe Teleman inequality is satisfied for this stratum iif one of these rectangles sums to 2 or more.\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.generic_ext-Tuple{Quiver, Vector{Int64}, Vector{Int64}}","page":"All methods","title":"QuiverTools.generic_ext","text":"Computes the dimension of the mathrmExt^1 group between generic representations of dimension vectors a and b.\n\nAccording to Thm. 5.4 in Schofield's General representations of quivers, we have\n\next(ab) = max- langle c branglectextis a generic subdimension vector of  a\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.generic_hom-Tuple{Quiver, Vector{Int64}, Vector{Int64}}","page":"All methods","title":"QuiverTools.generic_hom","text":"Computes the dimension of the mathrmHom group between generic representations of dimension vectors a and b.\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.has_semistables","page":"All methods","title":"QuiverTools.has_semistables","text":"Checks if there is a theta-semistable representation of dimension vector d.\n\nExamples:\n\njulia> A2 = mKronecker_quiver(1); theta = [1,-1];\n\njulia> has_semistables(A2, [1,1], theta)\ntrue\n\njulia> has_semistables(A2, [2,2], theta)\ntrue\n\njulia> has_semistables(A2, [1,2], theta)\nfalse\n\njulia> has_semistables(A2, [0,0], theta)\ntrue\n\njulia> # The 3-Kronecker quiver:\n\njulia> K3 = mKronecker_quiver(3); theta = [3,-2];\n\njulia> has_semistables(K3, [2,3], theta)\ntrue\n\njulia> has_semistables(K3, [1,4], theta)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"methods/#QuiverTools.has_stables","page":"All methods","title":"QuiverTools.has_stables","text":"Checks if Q has a theta-stable representation of dimension vector d.\n\nExamples:\n\njulia> Q = mKronecker_quiver(3); d = [2,3]; theta = [3,-2];\n\njulia> has_stables(Q, d, theta)\ntrue\n\njulia> Q = mKronecker_quiver(2); d = [2,2]; theta = [1,-1];\n\njulia> has_stables(Q, d, theta)\nfalse\n\njulia> has_semistables(Q, d, theta)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"methods/#QuiverTools.in_fundamental_domain-Tuple{Quiver, Vector{Int64}}","page":"All methods","title":"QuiverTools.in_fundamental_domain","text":"Checks if the dimension vector d is in the fundamental domain of the quiver Q.\n\nThe fundamental domain is the cone of dimension vectors in mathbbZ^Q_0 such that the symmetric Tits form is negative on all the simple roots, i.e., for all vertices i,\n\n(s_i d) = langle d s_irangle + langle s_i drangle  leq 0\n\nwhere s_i is the dimension vector with all entries set to 0 and the i-th set to 1.\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.in_stable_cone","page":"All methods","title":"QuiverTools.in_stable_cone","text":"Checks if the stability parameter theta belongs to the cone of parameters admitting stable representations of dimension vector d. Assumes that the dimension vector d is Schurian (for now).\n\n\n\n\n\n","category":"function"},{"location":"methods/#QuiverTools.indegree-Tuple{Quiver, Int64}","page":"All methods","title":"QuiverTools.indegree","text":"Returns the number of incoming arrows to the vertex j.\n\nExamples:\n\njulia> Q = mKronecker_quiver(4);\n\njulia> indegree(Q, 1)\n0\n\njulia> indegree(Q, 2)\n4\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.is_Schur_root-Tuple{Quiver, Vector{Int64}}","page":"All methods","title":"QuiverTools.is_Schur_root","text":"Checks if d is a Schur root for Q.\n\nBy a lemma of Schofield (See Lemma 4.2 of arXiv:0802.2147), this is equivalent to the existence of a stable representation of dimension vector d for the canonical stability parameter.\n\nExamples:\n\njulia> Q = mKronecker_quiver(3); d = [2,3];\n\njulia> is_Schur_root(Q, d)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.is_acyclic-Tuple{Quiver}","page":"All methods","title":"QuiverTools.is_acyclic","text":"Checks wether the quiver is acyclic, i.e. has no oriented cycles.\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.is_amply_stable","page":"All methods","title":"QuiverTools.is_amply_stable","text":"Checks wether the dimension vector d is amply stable with respect to the slope function theta/denominator.\n\nThis means that the codimension of the unstable locus in the parameter space is at least 2.\n\n\n\n\n\n","category":"function"},{"location":"methods/#QuiverTools.is_connected-Tuple{Quiver}","page":"All methods","title":"QuiverTools.is_connected","text":"Checks wether the underlying graph of the quiver is connected.\n\nExamples:\n\njulia> Q = Quiver([0 1 0; 0 0 1; 1 0 0]);\n\njulia> is_connected(Q)\ntrue\n\njulia> Q = Quiver([0 1 0; 1 0 0; 0 0 2]);\n\njulia> is_connected(Q)\nfalse\n\njulia> # The 4-Kronecker quiver:\n\njulia> Q = mKronecker_quiver(4);\n\njulia> is_connected(Q)\ntrue\n\njulia> # The 4-loop quiver:\n\njulia> Q = loop_quiver(4);\n\njulia> is_connected(Q)\ntrue\n\njulia> # The 4-subspace quiver:\n\njulia> Q = subspace_quiver(4);\n\njulia> is_connected(Q)\ntrue\n\njulia> # The A10 quiver:\n\njulia> A10 = Quiver(   [0 1 0 0 0 0 0 0 0 0;\n                        0 0 1 0 0 0 0 0 0 0;\n                        0 0 0 1 0 0 0 0 0 0;\n                        0 0 0 0 1 0 0 0 0 0;\n                        0 0 0 0 0 1 0 0 0 0;\n                        0 0 0 0 0 0 1 0 0 0;\n                        0 0 0 0 0 0 0 1 0 0;\n                        0 0 0 0 0 0 0 0 1 0;\n                        0 0 0 0 0 0 0 0 0 1;\n                        0 0 0 0 0 0 0 0 0 0] );\n\njulia> is_connected(A10)\ntrue\n\njulia> # The A10 quiver without one arrow:\n\njulia> A10 = Quiver(   [0 1 0 0 0 0 0 0 0 0;\n                        0 0 1 0 0 0 0 0 0 0;\n                        0 0 0 1 0 0 0 0 0 0;\n                        0 0 0 0 1 0 0 0 0 0;\n                        0 0 0 0 0 1 0 0 0 0;\n                        0 0 0 0 0 0 0 0 0 0;\n                        0 0 0 0 0 0 0 1 0 0;\n                        0 0 0 0 0 0 0 0 1 0;\n                        0 0 0 0 0 0 0 0 0 1;\n                        0 0 0 0 0 0 0 0 0 0] );\n\njulia> is_connected(A10)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.is_coprime-Tuple{Vector{Int64}, Vector{Int64}}","page":"All methods","title":"QuiverTools.is_coprime","text":"Checks wether the given dimension vector d is theta-coprime for the stability parameter theta.\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.is_coprime-Tuple{Vector{Int64}}","page":"All methods","title":"QuiverTools.is_coprime","text":"Checks if the gcd of all the entries of d is 1.\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.is_generic_subdimension_vector-Tuple{Quiver, Vector{Int64}, Vector{Int64}}","page":"All methods","title":"QuiverTools.is_generic_subdimension_vector","text":"Checks if e is a generic subdimension vector of d.\n\nA dimension vector e is called a generic subdimension vector of d if a generic representation of dimension vector d possesses a subrepresentation of dimension vector e.\n\nBy a result of Schofield (see Thm. 5.3 of arXiv:0802.2147), e is a generic subdimension vector of d if and only if\n\ned-e geq 0\n\nfor all generic subdimension vectors e of e.\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.is_sink-Tuple{Quiver, Int64}","page":"All methods","title":"QuiverTools.is_sink","text":"Checks if the vertex j is a sink, i.e., a vertex with no outgoing arrows.\n\nExamples:\n\njulia> Q = mKronecker_quiver(4);\n\njulia> is_sink(Q, 1)\nfalse\n\njulia> is_sink(Q, 2)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.is_source-Tuple{Quiver, Int64}","page":"All methods","title":"QuiverTools.is_source","text":"Checks if the vertex i is a source, i.e., a vertex with no incoming arrows.\n\nExamples:\n\njulia> Q = mKronecker_quiver(4);\n\njulia> is_source(Q, 1)\ntrue\n\njulia> is_source(Q, 2)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.narrows-Tuple{Quiver}","page":"All methods","title":"QuiverTools.narrows","text":"Returns the number of arrows of the quiver.\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.nvertices-Tuple{Quiver}","page":"All methods","title":"QuiverTools.nvertices","text":"Returns the number of vertices of the quiver.\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.opposite_quiver-Tuple{Quiver}","page":"All methods","title":"QuiverTools.opposite_quiver","text":"\" Returns a Quiver with the same vertices and an arrow j to i for every arrow  i to j in the original quiver.\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.outdegree-Tuple{Quiver, Int64}","page":"All methods","title":"QuiverTools.outdegree","text":"Returns the number of outgoing arrows from the vertex i.\n\nExamples:\n\njulia> Q = mKronecker_quiver(4);\n\njulia> outdegree(Q, 1)\n4\n\njulia> outdegree(Q, 2)\n0\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.slope","page":"All methods","title":"QuiverTools.slope","text":"Returns the slope of the dimension vector d with respect to the stability parameter theta and a choice of a denominator function.\n\n\n\n\n\n","category":"function"},{"location":"methods/#QuiverTools.smooth_model_quiver-Tuple{Quiver, Vector{Int64}}","page":"All methods","title":"QuiverTools.smooth_model_quiver","text":"Computes the quiver hatQ defined in arXiv:0706.4306 for the given quiver Q and a given subdimension vector e.\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.solve-Tuple{Any, Any}","page":"All methods","title":"QuiverTools.solve","text":"Solve Acdot x = b for A upper triangular via back substitution\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.symmetric_polynomial-Tuple{Any, Int64}","page":"All methods","title":"QuiverTools.symmetric_polynomial","text":"Returns the symmetric polynomial of degree degree in the variables vars.\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.underlying_graph-Tuple{Quiver}","page":"All methods","title":"QuiverTools.underlying_graph","text":"Returns the (necessarily symmetric) adjacency matrix of the underlying graph of the quiver.\n\n\n\n\n\n","category":"method"},{"location":"methods/#QuiverTools.weight_irreducible_component_canonical_on_stratum","page":"All methods","title":"QuiverTools.weight_irreducible_component_canonical_on_stratum","text":"Computes the weight of the irreducible component of omega_R_Z on a Harder-Narasimhan stratum for the 1-PS corresponding to each HN type. More explicitly, if omega_X = mathcalO(rH), this returns the weight of the pullback of O(H) on the given stratum.\n\n\n\n\n\n","category":"function"},{"location":"methods/#QuiverTools.weights_endomorphism_universal_bundle_on_stratum","page":"All methods","title":"QuiverTools.weights_endomorphism_universal_bundle_on_stratum","text":"Computes the weights of the endomorphism of the universal bundle U_i otimes U_j on the given Harder-Narasimhan stratum for the 1-PS relative to the HN type.\n\n\n\n\n\n","category":"function"},{"location":"methods/#QuiverTools.weights_universal_bundle_onstratum","page":"All methods","title":"QuiverTools.weights_universal_bundle_onstratum","text":"Returns the weights of a universal bundle U_i(a) for the linearization a for the 1-PS corresponding to the given HN type.\n\n\n\n\n\n","category":"function"},{"location":"#QuiverTools","page":"QuiverTools","title":"QuiverTools","text":"","category":"section"},{"location":"#Contents","page":"QuiverTools","title":"Contents","text":"","category":"section"},{"location":"","page":"QuiverTools","title":"QuiverTools","text":"","category":"page"},{"location":"#Introduction","page":"QuiverTools","title":"Introduction","text":"","category":"section"},{"location":"","page":"QuiverTools","title":"QuiverTools","text":"QuiverTools is a software suite in development for treatment of quiver representations, their roots, their moduli spaces and computations of several invariants of these.","category":"page"},{"location":"","page":"QuiverTools","title":"QuiverTools","text":"QuiverTools will be available as a Julia package and as a Sage library.","category":"page"},{"location":"#Installation","page":"QuiverTools","title":"Installation","text":"","category":"section"},{"location":"","page":"QuiverTools","title":"QuiverTools","text":"At the moment the package is not registered, so you can install it by running the following command in the Julia REPL:","category":"page"},{"location":"","page":"QuiverTools","title":"QuiverTools","text":"pkg> no-you-can-not-install-it-yet","category":"page"},{"location":"#Acknowledgements","page":"QuiverTools","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"QuiverTools","title":"QuiverTools","text":"QuiverTools is being developed by P. Belmans, H. Franzen and G. Petrella.","category":"page"},{"location":"","page":"QuiverTools","title":"QuiverTools","text":"The Julia version is developed and maintained by G. Petrella.","category":"page"},{"location":"","page":"QuiverTools","title":"QuiverTools","text":"G. Petrella was supported by the Luxembourg National Research Fund (FNR–17953441).","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/#Installation","page":"Tutorial","title":"Installation","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"At the moment the package is not registered, so you can install it by running the following command in the Julia REPL:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"pkg> no-you-can-not-install-it-yet","category":"page"},{"location":"tutorial/#Basic-functionalities","page":"Tutorial","title":"Basic functionalities","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To start using QuiverTools in the REPL, one first must import it.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> using QuiverTools","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Quivers can be built by passing the adjacency matrix to the Quiver() constructor:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> Quiver([0 3; 0 0])\nQuiver with adjacency matrix [0 3; 0 0]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The constructor accepts an optional string for naming the quiver:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> MyQ = Quiver([0 3; 0 0], \"My personal quiver\")\nMy personal quiver, with adjacency matrix [0 3; 0 0]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"QuiverTools has several constructors in place for many common examples:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> mKronecker_quiver(4)\n4-Kronecker quiver, with adjacency matrix [0 4; 0 0]\n\njulia> loop_quiver(5)\n5-loop quiver, with adjacency matrix [5;;]\n\njulia> subspace_quiver(3)\n3-subspace quiver, with adjacency matrix [0 0 0 1; 0 0 0 1; 0 0 0 1; 0 0 0 0]\n\njulia> three_vertex_quiver(1, 6, 7)\nAn acyclic 3-vertex quiver, with adjacency matrix [0 1 6; 0 0 7; 0 0 0]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Dimension vectors and stability parameters are represented by Vector{Int} objects:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> Q = mKronecker_quiver(3); d = [2,3];\n\njulia> θ = canonical_stability(Q, d)\n2-element Vector{Int64}:\n  9\n -6\n\njulia> is_coprime(d, θ)\ntrue","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Here, is_coprime() checks if d is θ-coprime, i.e., if none of the proper subdimension vectors 0 neq d nleq d satisfies theta cdot d = 0.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The bilinear Euler form relative to a quiver Q of any two vectors in mathbbZ^Q_0 can be computed:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> Q = mKronecker_quiver(3); d = [2,2]; e = [3,4];\n\njulia> Euler_form(Q, d, e)\n-10\n\njulia> Euler_form(Q, e, d)\n-4","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This allows to verify whether any given dimension vector belongs to the fundamental domain of the problem.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The fundamental domain is the cone of dimension vectors in mathbbZ^Q_0 such that the symmetric Tits form is negative on all the simple roots, i.e., for all vertices i,","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(s_i d) = langle d s_irangle + langle s_i drangle  leq 0","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"where s_i is the dimension vector with all entries set to 0 and the i-th set to 1.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> QuiverTools.in_fundamental_domain(Q, d)\ntrue\n\njulia> QuiverTools.in_fundamental_domain(Q, [1,3])\nfalse","category":"page"},{"location":"tutorial/#Stable-and-semistable-dimension-vectors","page":"Tutorial","title":"Stable and semistable dimension vectors","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"One can check if semistable, respectively stable representations exist for a given dimension vector and stability parameter:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> Q = mKronecker_quiver(3); d = [2,3]; θ = [3,-2];\n\njulia> has_semistables(Q, d, θ)\ntrue\n\njulia> has_stables(Q, d, θ)\ntrue\n\njulia> K2 = mKronecker_quiver(2);\n\njulia> has_stables(K2, [2,2], [1,-1])\nfalse\n\njulia> has_semistables(K2, [2,2], [1,-1])\ntrue","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"One can also determine whether stable representations exist at all for a given dimension vector by checking if it is a Schur root:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> Q = mKronecker_quiver(3); d = [2, 2];\n\njulia> QuiverTools.is_Schur_root(Q, d)\ntrue\n\njulia> K2 = mKronecker_quiver(2);\n\njulia> QuiverTools.is_Schur_root(K2, d)\nfalse","category":"page"},{"location":"tutorial/#Harder-Narasimhan-types","page":"Tutorial","title":"Harder-Narasimhan types","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This module provides methods to investigate the Harder-Narasimhan stratification of the parameter space mathrmR(Qmathbfd).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> Q = mKronecker_quiver(3); d = [2, 3]; θ = [3, -2];\n\njulia> allHNtypes(Q, d, θ)\n8-element Vector{Vector{Vector{Int64}}}:\n [[2, 3]]\n [[1, 1], [1, 2]]\n [[2, 2], [0, 1]]\n [[2, 1], [0, 2]]\n [[1, 0], [1, 3]]\n [[1, 0], [1, 2], [0, 1]]\n [[1, 0], [1, 1], [0, 2]]\n [[2, 0], [0, 3]]\n\njulia> is_amply_stable(Q, d, θ)\ntrue","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The method is_amply_stable() determines whether the codimension of the θ-semistable locus, mathrmR^theta-sst(Qmathbfd)subsetmathrmR(Qmathbfd), is at least 2.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The method all_HN_types() provides a list of all the Harder-Narasimhan types that appear in the problem.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The method all_Teleman_bounds() computes the bounds to apply Teleman quantization on the non-dense strata. The output is a dictionary whose keys are the HN types and whose values are the weights themselves.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> Q = mKronecker_quiver(3); d = [2, 3]; θ = [3, -2];\n\njulia> all_Teleman_bounds(Q, d, θ)\nDict{Vector{Vector{Int64}}, Int64} with 7 entries:\n  [[2, 2], [0, 1]]         => 20\n  [[2, 1], [0, 2]]         => 100\n  [[1, 0], [1, 2], [0, 1]] => 100\n  [[1, 0], [1, 3]]         => 120\n  [[1, 0], [1, 1], [0, 2]] => 90\n  [[1, 1], [1, 2]]         => 15\n  [[2, 0], [0, 3]]         => 90","category":"page"},{"location":"tutorial/#Verify-Teleman-inequalities","page":"Tutorial","title":"Verify Teleman inequalities","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In the following example, for each ij and on each Harder-Narasimhan stratum, we compute the weight of mathcalU_i^vee otimes mathcalU_j relative to the 1-PS corresponding to the HN stratum. These are then compared to the Teleman bounds.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> Q = mKronecker_quiver(3); d = [2, 3]; θ = [3, -2];\n\njulia> hn = all_Teleman_bounds(Q, d, θ)\nDict{Vector{Vector{Int64}}, Int64} with 7 entries:\n  [[2, 2], [0, 1]]         => 20\n  [[2, 1], [0, 2]]         => 100\n  [[1, 0], [1, 2], [0, 1]] => 100\n  [[1, 0], [1, 3]]         => 120\n  [[1, 0], [1, 1], [0, 2]] => 90\n  [[1, 1], [1, 2]]         => 15\n  [[2, 0], [0, 3]]         => 90\n\njulia> endom = all_weights_endomorphisms_universal_bundle(Q, d, θ)\nDict{Vector{Vector{Int64}}, Vector{Int64}} with 7 entries:\n  [[2, 2], [0, 1]]         => [0, 5, -5, 0]\n  [[2, 1], [0, 2]]         => [0, 10, -10, 0]\n  [[1, 0], [1, 2], [0, 1]] => [0, 10, 15, -10, 0, 5, -15, -5, 0]\n  [[1, 0], [1, 3]]         => [0, 15, -15, 0]\n  [[1, 0], [1, 1], [0, 2]] => [0, 5, 10, -5, 0, 5, -10, -5, 0]\n  [[1, 1], [1, 2]]         => [0, 5, -5, 0]\n  [[2, 0], [0, 3]]         => [0, 5, -5, 0]\n\njulia> all(maximum(endom[key]) < hn[key] for key in keys(hn))\ntrue","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The fact that all of these inequalities are satisfied allows to conclude that the higher cohomology of mathcalU_i^vee otimes mathcalU_j vanishes.","category":"page"},{"location":"tutorial/#Canonical-decompositions-and-roots","page":"Tutorial","title":"Canonical decompositions and roots","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"QuiverTools provides a method to compute the canonical decomposition of a dimension vector.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Given a dimension vector d, the canonical decomposition is a list of Shur roots beta_i such that d = sum_i beta_i and mathrmext(beta_ibeta_j) = 0 for all i neq j.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"It is a theorem of Schofield that the canonical decomposition exists and is described by the condition above. If this is the canonical deconstruction of d, then the general representation of dimension vector d decomposes as a direct sum of indecomposable representations of dimension vector beta_i.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> canonical_decomposition(Q, d)\n1-element Vector{Vector{Int64}}:\n [2, 3]\n\njulia> canonical_decomposition(Q, [12, 3])\n6-element Vector{Vector{Int64}}:\n [1, 0]\n [1, 0]\n [1, 0]\n [3, 1]\n [3, 1]\n [3, 1]\n\njulia> canonical_decomposition(Q, [12, 4])\n4-element Vector{Vector{Int64}}:\n [3, 1]\n [3, 1]\n [3, 1]\n [3, 1]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"QuiverTools also implements computations of generic hom and ext for dimension vectors.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> e = [1, 2];\n\njulia> generic_hom(Q, d, e)\n0\n\njulia> generic_hom(Q, e, d)\n0\n\njulia> generic_ext(Q, d, e)\n4\n\njulia> generic_ext(Q, e, d)\n1","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This allows to determine wether a root is real, imaginary isotropic or imaginary anisotropic.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> ds = QuiverTools.all_subdimension_vectors([5, 5])\n6×6 Matrix{Vector{Int64}}:\n [0, 0]  [0, 1]  [0, 2]  [0, 3]  [0, 4]  [0, 5]\n [1, 0]  [1, 1]  [1, 2]  [1, 3]  [1, 4]  [1, 5]\n [2, 0]  [2, 1]  [2, 2]  [2, 3]  [2, 4]  [2, 5]\n [3, 0]  [3, 1]  [3, 2]  [3, 3]  [3, 4]  [3, 5]\n [4, 0]  [4, 1]  [4, 2]  [4, 3]  [4, 4]  [4, 5]\n [5, 0]  [5, 1]  [5, 2]  [5, 3]  [5, 4]  [5, 5]\n\njulia> filter(d -> QuiverTools.is_real_root(Q, d), ds)\n4-element Vector{Vector{Int64}}:\n [1, 0]\n [0, 1]\n [3, 1]\n [1, 3]\n\njulia> filter(d -> QuiverTools.is_isotropic_root(Q, d), ds)\n1-element Vector{Vector{Int64}}:\n [0, 0]\n\njulia> filter(d -> QuiverTools.is_imaginary_root(Q, d), ds)\n20-element Vector{Vector{Int64}}:\n [0, 0]\n [1, 1]\n [2, 1]\n [1, 2]\n [2, 2]\n [3, 2]\n [4, 2]\n [5, 2]\n [2, 3]\n [3, 3]\n [4, 3]\n [5, 3]\n [2, 4]\n [3, 4]\n [4, 4]\n [5, 4]\n [2, 5]\n [3, 5]\n [4, 5]\n [5, 5]","category":"page"},{"location":"tutorial/#Hodge-polynomials","page":"Tutorial","title":"Hodge polynomials","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"QuiverTools features an implementation of the Hodge polynomial of quiver moduli, if the base field is mathbbC and the dimension vector is a coprime Schurian root.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> Q = mKronecker_quiver(3); d = [2, 3]; θ = canonical_stability(Q, d);\n\njulia> Hodge_polynomial(Q, d, θ)\nx^6*y^6 + x^5*y^5 + 3*x^4*y^4 + 3*x^3*y^3 + 3*x^2*y^2 + x*y + 1\n\njulia> Hodge_diamond(Q, d, θ)\n7×7 Matrix{Int64}:\n 1  0  0  0  0  0  0\n 0  1  0  0  0  0  0\n 0  0  3  0  0  0  0\n 0  0  0  3  0  0  0\n 0  0  0  0  3  0  0\n 0  0  0  0  0  1  0\n 0  0  0  0  0  0  1","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Note that the i j-th entry of the matrix representing the Hodge diamond is h^ij. In other words, the point of the diamond is on the upper left side of the matrix.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This allows us to conclude that the Picard rank of the moduli space is 1.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> Picard_rank(Q, d, θ)\n1","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For performance-oriented computations, one can use some theoretical results to get a slightly faster computation of the Hodge polynomial, which skips some safety checks and returns the Hodge polynomial without performing the change of variables q to x cdot y.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> QuiverTools._Hodge_polynomial_fast(Q, d, θ)\nq^6 + q^5 + 3*q^4 + 3*q^3 + 3*q^2 + q + 1\n\njulia> using BenchmarkTools\n\njulia> @benchmark Hodge_polynomial(Q, d, θ)\nBenchmarkTools.Trial: 10000 samples with 1 evaluation.\n Range (min … max):  117.500 μs … 109.571 ms  ┊ GC (min … max):  0.00% … 41.09%\n Time  (median):     123.188 μs               ┊ GC (median):     0.00%\n Time  (mean ± σ):   230.718 μs ±   3.241 ms  ┊ GC (mean ± σ):  18.81% ±  1.36%\n\n  \t   ▂▄██▇▅▄▃▂▂                                                  \n  ▂▄▇███████████▇▆▅▅▄▄▃▃▂▂▂▂▂▂▂▂▂▂▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁ ▃\n  118 μs           Histogram: frequency by time          155 μs <\n\n Memory estimate: 136.06 KiB, allocs estimate: 3408.\n\njulia> @benchmark QuiverTools._Hodge_polynomial_fast(Q, d, θ)\nBenchmarkTools.Trial: 10000 samples with 1 evaluation.\n Range (min … max):  114.625 μs … 110.717 ms  ┊ GC (min … max):  0.00% … 40.68%\n Time  (median):     120.042 μs               ┊ GC (median):     0.00%\n Time  (mean ± σ):   219.409 μs ±   3.148 ms  ┊ GC (mean ± σ):  18.09% ±  1.28%\n\n        ▄▅▆▆█▇▆▇▅▄▂▂▁▁                                           \n  ▁▂▃▅▇███████████████▇█▆▆▆▄▅▄▄▃▃▃▃▂▂▂▂▂▂▂▂▂▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁ ▃\n  115 μs           Histogram: frequency by time          139 μs <\n\n Memory estimate: 132.34 KiB, allocs estimate: 3327.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"<!– ","category":"page"},{"location":"tutorial/#Bundle-library","page":"Tutorial","title":"Bundle library","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"QuiverTools contains (for now) a basic implementation of Bundle objects.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"These are meant to be used as containers to perform computations with weights or linearizations.","category":"page"},{"location":"tutorial/#Functionality","page":"Tutorial","title":"Functionality","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"One can create a Bundle object by passing a list of weights and the rank to the constructor:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> Bundle([1, 2, 3], 3)\nBundle of rank 3 with weights: [1, 2, 3]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Note: the rank is not computed automatically from the weights. This is a design choice, to force a sanity check on the user. Should there be the necessity to bypass this, the expected rank is the length of the list of weights.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Direct sum, tensor product, wedge and symmetric product are implemented:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> U = Bundle([1, 2, 3], 3); V = Bundle([4, 5], 2);\njulia> U ⊕ V\nBundle of rank 5 with weights: [1, 2, 3, 4, 5]\n\njulia> U ⊗ V\nBundle of rank 6 with weights: [5, 6, 6, 7, 7, 8]\n\njulia> det(U)\nBundle of rank 1 with weights: [6]\n\njulia> wedge(U, 0)\nBundle of rank 1 with weights: [0]\njulia> wedge(U, 1)\nBundle of rank 3 with weights: [1, 2, 3]\njulia> wedge(U, 2)\nBundle of rank 3 with weights: [3, 4, 5]\njulia> wedge(U, 3)\nBundle of rank 1 with weights: [6]\njulia> wedge(U, 4)\nBundle of rank 0 with weights: Int64[]\n\njulia> symm(U,0)\nBundle of rank 1 with weights: [0]\njulia> symm(U,1)\nBundle of rank 3 with weights: [1, 2, 3]\njulia> symm(U,2)\nBundle of rank 6 with weights: [2, 3, 4, 4, 5, 6]\njulia> symm(U,3)\nBundle of rank 10 with weights: [3, 4, 5, 5, 6, 7, 6, 7, 8, 9]\njulia> symm(U,4)\nBundle of rank 15 with weights: [4, 5, 6, 6, 7, 8, 7, 8, 9, 10, 8, 9, 10, 11, 12]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A basic implementation of box products is also available:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"\njulia> U = Bundle([1, 2, 3], 3); V = Bundle([4, 5], 2);\njulia> a = U ⊠ V\nBundle of rank 6 with weights: [[1, 4], [1, 5], [2, 4], [2, 5], [3, 4], [3, 5]]\njulia> b = V ⊠ V\nBundle of rank 4 with weights: [[4, 4], [4, 5], [5, 4], [5, 5]]\n\n\n\njulia> a ⊗ b\nBundle of rank 24 with weights: [[5, 8], [5, 9], [6, 8], [6, 9], [5, 9], [5, 10], [6, 9], [6, 10], [6, 8], [6, 9], [7, 8], [7, 9], [6, 9], [6, 10], [7, 9], [7, 10], [7, 8], [7, 9], [8, 8], [8, 9], [7, 9], [7, 10], [8, 9], [8, 10]]\n\njulia> a ⊕ b\nBundle of rank 10 with weights: [[1, 4], [1, 5], [2, 4], [2, 5], [3, 4], [3, 5], [4, 4], [4, 5], [5, 4], [5, 5]]\n\njulia> wedge(b,2)\nBundle of rank 6 with weights: [[8, 9], [9, 8], [9, 9], [9, 9], [9, 10], [10, 9]]\n\njulia> wedge(b,3)\nBundle of rank 4 with weights: [[13, 13], [13, 14], [14, 13], [14, 14]]\n\njulia> wedge(b,5)\nBundle of rank 0 with weights: Vector{Int64}[]\n\njulia> symm(a,2)\nBundle of rank 21 with weights: [[2, 8], [2, 9], [3, 8], [3, 9], [4, 8], [4, 9], [2, 10], [3, 9], [3, 10], [4, 9], [4, 10], [4, 8], [4, 9], [5, 8], [5, 9], [4, 10], [5, 9], [5, 10], [6, 8], [6, 9], [6, 10]]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"One use case is creating Bundle objects containing weights of linearisations with respect to 1-PSs and then verifying Teleman inequality for objects built with complex combinations of tensor, box and exterior products.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Another use case is defining line bundles on a projective space and then computing the effects of direct summands, tensor products and exterior products on the linearization. One such example is the computation of the Eagon-Northcott complex for P^n, done below.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> Q = mKronecker_quiver(2);\njulia> U = [Bundle([-1], 1),Bundle([0], 1)]\n2-element Vector{Bundle}:\n  Bundle of rank 1, with weights: [-1]\n  Bundle of rank 1, with weights: [0]\n\njulia> EagonNorthcottcomplex(Q,U)\n1-element Vector{Bundle}:\n  Bundle of rank 1, with weights: [[-1, -1]]\n\n\njulia> Q = mKronecker_quiver(5);\njulia> EagonNorthcottcomplex(Q,U)\n4-element Vector{Bundle}:\n  Bundle of rank 10, with weights: [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1]]\n  Bundle of rank 20, with weights: [[-1, -2], [-2, -1], [-1, -2], [-2, -1], [-1, -2], [-2, -1], [-1, -2], [-2, -1], [-1, -2], [-2, -1], [-1, -2], [-2, -1], [-1, -2], [-2, -1], [-1, -2], [-2, -1], [-1, -2], [-2, -1], [-1, -2], [-2, -1]]\n  Bundle of rank 15, with weights: [[-1, -3], [-2, -2], [-3, -1], [-1, -3], [-2, -2], [-3, -1], [-1, -3], [-2, -2], [-3, -1], [-1, -3], [-2, -2], [-3, -1], [-1, -3], [-2, -2], [-3, -1]]\n  Bundle of rank 4, with weights: [[-1, -4], [-2, -3], [-3, -2], [-4, -1]]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Each Bundle object contains a rank and a list of weights.  –>","category":"page"}]
}
